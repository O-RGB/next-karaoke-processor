<!DOCTYPE html>
<html lang="th">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index, follow" />
    <meta
      name="description"
      content="‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡∏ü‡∏£‡∏µ ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö .EMK, .DBF ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏° ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏ß‡πá‡∏ö‡πÑ‡∏î‡πâ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡πÅ‡∏•‡∏∞‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô"
    />
    <meta
      name="keywords"
      content="‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞, EMK converter, DBF converter, karaoke converter ‡πÑ‡∏ó‡∏¢, ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡∏ü‡∏£‡∏µ, ‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡∏≠‡∏≠‡∏ô‡πÑ‡∏•‡∏ô‡πå"
    />
    <title>Next Karaoke Processor - ‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡∏ü‡∏£‡∏µ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      :root {
        --primary: #6366f1;
        --primary-dark: #4f46e5;
        --secondary: #8b5cf6;
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --dark: #1e293b;
        --light: #f8fafc;
        --gray: #64748b;
        --border: #e2e8f0;
      }
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
        color: var(--dark);
      }
      .container {
        max-width: 800px;
        margin: 0 auto;
      }
      .hero {
        text-align: center;
        color: white;
        margin-bottom: 30px;
        animation: fadeInDown 0.8s ease-out;
      }
      .hero h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }
      .hero .subtitle {
        font-size: 1.1rem;
        opacity: 0.9;
        margin-bottom: 15px;
      }
      .hero .features {
        display: flex;
        justify-content: center;
        gap: 20px;
        flex-wrap: wrap;
        margin-top: 15px;
      }
      .feature-badge {
        background: rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
        padding: 8px 16px;
        border-radius: 50px;
        font-size: 0.85rem;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .card {
        background: white;
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 15px 45px rgba(0, 0, 0, 0.25);
        margin-bottom: 15px;
        animation: fadeInUp 0.8s ease-out;
      }
      .card-header {
        border-bottom: 2px solid var(--border);
        padding-bottom: 15px;
        margin-bottom: 20px;
      }
      .card-header h2 {
        color: var(--primary);
        font-size: 1.5rem;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .alert {
        background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
        border-left: 4px solid var(--warning);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        line-height: 1.5;
        font-size: 0.9rem;
      }
      .alert strong {
        display: block;
        margin-bottom: 8px;
        color: #92400e;
      }
      .form-section {
        margin-bottom: 15px;
      }
      .form-section label {
        display: block;
        font-weight: 600;
        margin-bottom: 8px;
        color: var(--dark);
        font-size: 0.9rem;
      }
      .btn-group {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 6px;
        flex: 1;
        justify-content: center;
        min-width: 120px;
      }
      .btn-primary {
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--secondary) 100%
        );
        color: white;
      }
      .btn-primary:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(99, 102, 241, 0.3);
      }
      .btn-success {
        background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
        color: white;
      }
      .btn-success:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(16, 185, 129, 0.3);
      }
      .btn-danger {
        background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
        color: white;
      }
      .btn-danger:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(239, 68, 68, 0.3);
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .file-info {
        background: var(--light);
        padding: 12px 16px;
        border-radius: 8px;
        margin-top: 10px;
        border: 2px dashed var(--border);
        text-align: center;
        color: var(--gray);
        font-weight: 500;
        font-size: 0.9rem;
      }
      .file-info.active {
        background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
        border-color: var(--primary);
        color: var(--primary-dark);
      }
      input[type="number"] {
        width: 100%;
        padding: 10px 14px;
        border: 2px solid var(--border);
        border-radius: 8px;
        font-size: 0.95rem;
        transition: all 0.3s ease;
      }
      input[type="number"]:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
      }
      .checkbox-group {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 12px;
        background: var(--light);
        border-radius: 8px;
        margin-bottom: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.9rem;
      }
      .checkbox-group:hover {
        background: #e0e7ff;
      }
      .checkbox-group input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--primary);
      }
      .checkbox-group label {
        cursor: pointer;
        margin: 0;
        flex: 1;
      }
      .progress-section {
        margin-top: 20px;
      }
      .status {
        text-align: center;
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: 15px;
        color: var(--primary);
        padding: 12px;
        background: var(--light);
        border-radius: 8px;
      }
      .progress-bar {
        width: 100%;
        height: 30px;
        background: var(--light);
        border-radius: 15px;
        overflow: hidden;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 15px;
      }
      .progress-fill {
        height: 100%;
        background: linear-gradient(
          90deg,
          var(--primary) 0%,
          var(--secondary) 100%
        );
        transition: width 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 600;
        font-size: 0.85rem;
      }
      .log-box {
        background: #1e293b;
        border-radius: 8px;
        padding: 10px;
        min-height: 250px;
        max-height: 250px;
        overflow-y: auto;
        font-family: "Courier New", monospace;
        font-size: 0.8rem;
        box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.5);
      }
      .log-entry {
        padding: 3px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      .log-entry:last-child {
        border-bottom: none;
      }
      .log-timestamp {
        color: #94a3b8;
        margin-right: 8px;
      }
      .log-message {
        color: #e2e8f0;
      }
      .log-info .log-message {
        color: #60a5fa;
      }
      .log-warning .log-message {
        color: #fbbf24;
      }
      .log-error .log-message {
        color: #f87171;
      }
      .settings-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 15px;
      }
      .footer {
        text-align: center;
        color: white;
        margin-top: 30px;
        padding: 15px;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 10px;
        font-size: 0.85rem;
      }
      .footer a {
        color: white;
        text-decoration: none;
        font-weight: 600;
      }
      .footer a:hover {
        text-decoration: underline;
      }
      .accordion {
        margin-bottom: 15px;
      }
      .accordion-header {
        background: var(--light);
        padding: 12px 15px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        color: var(--primary);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .accordion-content {
        max-height: 1000px; /* ‡πÄ‡∏õ‡∏¥‡∏î‡πÇ‡∏î‡∏¢ default */
        overflow: hidden;
        transition: max-height 0.3s ease;
        padding: 15px;
        background: #fff;
        border-radius: 10px;
        margin-top: 5px;
        opacity: 1;
      }
      .accordion-content.closed {
        max-height: 0;
        padding: 0px;
        margin-top: 0px;
        opacity: 0;
      }
      .accordion-arrow {
        transition: transform 0.3s ease;
      }
      .accordion-arrow.closed {
        transform: rotate(180deg);
      }
      .content-section {
        background: white;
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 15px;
        box-shadow: 0 15px 45px rgba(0, 0, 0, 0.25);
        animation: fadeInUp 0.8s ease-out;
      }
      .content-section h2 {
        color: var(--primary);
        font-size: 1.5rem;
        margin-bottom: 15px;
      }
      .content-section p {
        line-height: 1.6;
        color: var(--gray);
        font-size: 0.9rem;
        margin-bottom: 10px;
      }
      @keyframes fadeInDown {
        from {
          opacity: 0;
          transform: translateY(-20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      @media (max-width: 768px) {
        .hero h1 {
          font-size: 1.8rem;
        }
        .hero .subtitle {
          font-size: 0.95rem;
        }
        .hero .features {
          gap: 10px;
        }
        .feature-badge {
          font-size: 0.75rem;
          padding: 6px 12px;
        }
        .card {
          padding: 15px;
        }
        .btn-group {
          flex-direction: column;
        }
        .btn {
          width: 100%;
        }
        .settings-grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Hero Section -->
      <div class="hero">
        <h1>üé§ Next Karaoke Processor</h1>
        <p class="subtitle">
          ‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡∏ü‡∏£‡∏µ ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°
          ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ö‡∏∏‡∏Ñ‡∏Ñ‡∏•‡πÅ‡∏•‡∏∞‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏Å‡∏é‡∏´‡∏°‡∏≤‡∏¢‡∏•‡∏¥‡∏Ç‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå
        </p>
        <div class="features">
          <div class="feature-badge">‚úì ‡∏ü‡∏£‡∏µ 100%</div>
          <div class="feature-badge">‚úì ‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢</div>
          <div class="feature-badge">‚úì ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢</div>
          <div class="feature-badge">‚úì ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö EMK, DBF</div>
        </div>
      </div>
      <!-- New Content Section -->
      <div class="content-section">
        <h2>üéµ ‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡πÅ‡∏•‡∏∞‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô</h2>
        <p>
          ‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏¢‡∏≠‡∏î‡∏ô‡∏¥‡∏¢‡∏°‡πÉ‡∏ô‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®‡πÑ‡∏ó‡∏¢‡∏ó‡∏µ‡πà‡∏ô‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ô‡∏∏‡∏Å‡∏™‡∏ô‡∏≤‡∏ô‡πÅ‡∏•‡∏∞‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏£‡∏á‡∏à‡∏≥‡∏î‡∏µ‡πÜ
          ‡∏ú‡πà‡∏≤‡∏ô‡∏ö‡∏ó‡πÄ‡∏û‡∏•‡∏á Next Karaoke Processor
          ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏ó‡∏µ‡πà‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡πÄ‡∏Å‡πà‡∏≤‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö .EMK ‡πÅ‡∏•‡∏∞ .DBF
          ‡πÉ‡∏´‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏¢‡∏∏‡∏Ñ‡∏™‡∏°‡∏±‡∏¢‡πÉ‡∏´‡∏°‡πà ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡∏ã‡∏≠‡∏ü‡∏ï‡πå‡πÅ‡∏ß‡∏£‡πå‡πÉ‡∏î‡πÜ
          ‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞ ‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• ‡∏Ñ‡∏∏‡∏ì‡∏à‡∏∞‡πÑ‡∏î‡πâ‡πÑ‡∏ü‡∏•‡πå
          ZIP ‡∏ó‡∏µ‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
        </p>
        <p>
          <strong>‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢‡πÜ:</strong><br />
          1. ‡∏Ñ‡∏•‡∏¥‡∏Å "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå SONG.DBF
          ‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏•‡∏á‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞<br />
          2. ‡∏õ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á (‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£) ‡πÄ‡∏ä‡πà‡∏ô ‡∏Ç‡∏ô‡∏≤‡∏î batch ‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á
          index<br />
          3. ‡∏Å‡∏î "‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•" ‡πÅ‡∏•‡∏∞‡∏£‡∏≠‡∏à‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à
          ‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì<br />
          4. ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏≤‡∏Å‡∏™‡πà‡∏ß‡∏ô "‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î" ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢!
        </p>
        <p>
          ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏ô‡∏µ‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏£‡∏∑‡πâ‡∏≠‡∏ü‡∏∑‡πâ‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏£‡∏á‡∏à‡∏≥‡πÄ‡∏Å‡πà‡∏≤‡πÜ
          ‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏û‡∏•‡∏á‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞ ‡πÇ‡∏î‡∏¢‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏Å‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏´‡∏≤‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÄ‡∏•‡πà‡∏ô‡∏¢‡∏≤‡∏Å‡πÉ‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
          ‡πÇ‡∏õ‡∏£‡∏î‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏•‡∏¥‡∏Ç‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
        </p>
      </div>
      <!-- Main Card -->
      <div class="card">
        <div class="card-header">
          <h2>üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô</h2>
        </div>
        <!-- Warning Alert -->
        <div class="alert">
          <strong>‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:</strong>
          ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö File System Access API (Chrome 86+, Edge
          86+) ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
        </div>
        <!-- Input Selection -->
        <div class="form-section">
          <label>üìÇ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞</label>
          <div class="btn-group">
            <button class="btn btn-primary" id="selectFolderBtn">
              üìÅ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå
            </button>
          </div>
          <div class="file-info" id="inputInfo">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡∏û‡∏∏‡∏ï</div>
        </div>
        <!-- Advanced Settings Accordion -->
        <div class="accordion">
          <div class="accordion-header" id="settingsToggle">
            ‚öôÔ∏è ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á
            <span class="accordion-arrow">‚ñº</span>
          </div>
          <div class="accordion-content closed" id="settingsContent">
            <!-- Settings Grid -->
            <div class="settings-grid">
              <div class="form-section">
                <label>üìä Batch Size (‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏û‡∏•‡∏á‡∏ï‡πà‡∏≠‡∏ä‡∏∏‡∏î)</label>
                <input
                  type="number"
                  id="batchSize"
                  value="100"
                  min="10"
                  max="1000"
                />
              </div>
              <div class="form-section">
                <label>üíæ ZIP Size Limit (MB)</label>
                <input
                  type="number"
                  id="zipSizeLimit"
                  value="300"
                  min="50"
                  max="5000"
                />
              </div>
              <div class="form-section">
                <label>‚öôÔ∏è CPU Throttle (ms)</label>
                <input
                  type="number"
                  id="cpuThrottle"
                  value="100"
                  min="0"
                  max="1000"
                  step="1"
                />
              </div>
            </div>
            <!-- Checkboxes -->
            <div class="checkbox-group">
              <input type="checkbox" id="performanceMode" checked />
              <label for="performanceMode"
                >‚ö° Performance Mode (‡πÉ‡∏ä‡πâ CPU ‡∏™‡∏π‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß)</label
              >
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="createZips" checked />
              <label for="createZips"
                >üì¶ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå ZIP ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏û‡∏•‡∏á (karaoke_*.zip)</label
              >
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="createIndexZip" checked />
              <label for="createIndexZip">üîç ‡∏™‡∏£‡πâ‡∏≤‡∏á index.zip ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤</label>
            </div>
          </div>
        </div>
        <!-- Action Buttons -->
        <div class="btn-group" style="margin-top: 20px">
          <button class="btn btn-success" id="startBtn">
            ‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
          </button>
          <button class="btn btn-danger" id="stopBtn" disabled>
            ‚èπÔ∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
          </button>
        </div>
        <!-- Progress Section -->
        <div class="progress-section">
          <div class="status" id="statusText">‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏á‡∏≤‡∏ô</div>
          <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%">
              0%
            </div>
          </div>
          <div class="log-box" id="logBox"></div>
        </div>
      </div>
      <!-- About Section (Accordion, ‡πÄ‡∏õ‡∏¥‡∏î‡πÇ‡∏î‡∏¢ default) -->
      <div class="accordion">
        <div class="accordion-header" id="aboutToggle">
          ‚ÑπÔ∏è ‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡πÄ‡∏£‡∏≤
          <span class="accordion-arrow">‚ñº</span>
        </div>
        <div class="accordion-content" id="aboutContent">
          <p style="line-height: 1.6; color: var(--gray); font-size: 0.9rem">
            <strong style="color: var(--dark)">Next Karaoke</strong>
            ‡∏ñ‡∏∑‡∏≠‡∏Å‡∏≥‡πÄ‡∏ô‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏Ñ‡∏ô‡πÄ‡∏•‡πá‡∏Å‡πÜ ‡∏ó‡∏µ‡πà‡∏´‡∏•‡∏á‡πÉ‡∏´‡∏•‡πÉ‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏û‡∏•‡∏á‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î
            ‡πÄ‡∏£‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏à‡∏≤‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ô‡∏∏‡∏Å‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡πâ‡∏≠‡∏á‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡∏Å‡∏±‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡πÅ‡∏•‡∏∞‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏£‡∏±‡∏ß
            ‡πÅ‡∏ï‡πà‡∏Å‡πá‡∏°‡∏±‡∏Å‡∏à‡∏∞‡πÄ‡∏à‡∏≠‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÉ‡∏´‡∏ç‡πà‡∏Ñ‡∏∑‡∏≠‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏û‡∏•‡∏á‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡πÄ‡∏Å‡πà‡∏≤‡πÜ ‡πÇ‡∏î‡∏¢‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÑ‡∏ü‡∏•‡πå .EMK
            ‡∏ó‡∏µ‡πà‡πÄ‡∏Ñ‡∏¢‡πÇ‡∏î‡πà‡∏á‡∏î‡∏±‡∏á‡πÉ‡∏ô‡∏≠‡∏î‡∏µ‡∏ï ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏±‡∏ö‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏™‡∏°‡∏±‡∏¢‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏î‡πâ
            ‡πÄ‡∏£‡∏≤‡∏à‡∏∂‡∏á‡πÄ‡∏´‡πá‡∏ô‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡πâ‡∏≤‡∏ô‡πÄ‡∏ó‡∏Ñ‡πÇ‡∏ô‡πÇ‡∏•‡∏¢‡∏µ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏ô‡∏µ‡πâ‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö‡∏ä‡∏∏‡∏°‡∏ä‡∏ô‡∏Ñ‡∏ô‡∏£‡∏±‡∏Å‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡πÉ‡∏ô‡πÑ‡∏ó‡∏¢
          </p>
          <p
            style="
              line-height: 1.6;
              color: var(--gray);
              margin-top: 10px;
              font-size: 0.9rem;
            "
          >
            ‡πÄ‡∏£‡∏≤‡∏ï‡∏±‡πâ‡∏á‡πÉ‡∏à‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
            ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÉ‡∏´‡πâ‡∏¢‡∏∏‡πà‡∏á‡∏¢‡∏≤‡∏Å ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å‡∏ó‡∏∏‡∏Å‡∏ó‡∏µ‡πà ‡∏ó‡∏∏‡∏Å‡πÄ‡∏ß‡∏•‡∏≤
            ‡πÅ‡∏•‡∏∞‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏Ñ‡∏∑‡∏≠
            <strong style="color: var(--success)">"‡∏ü‡∏£‡∏µ"</strong>
            ‡πÄ‡∏£‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏ß‡πà‡∏≤‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡∏Ñ‡∏ß‡∏£‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ö‡∏±‡∏ô‡πÄ‡∏ó‡∏¥‡∏á‡πÅ‡∏•‡∏∞‡πÑ‡∏î‡πâ‡∏£‡∏∑‡πâ‡∏≠‡∏ü‡∏∑‡πâ‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏£‡∏á‡∏à‡∏≥‡∏î‡∏µ‡πÜ
            ‡∏ú‡πà‡∏≤‡∏ô‡∏ö‡∏ó‡πÄ‡∏û‡∏•‡∏á‡πÄ‡∏Å‡πà‡∏≤‡πÜ ‡∏ó‡∏µ‡πà‡∏û‡∏ß‡∏Å‡πÄ‡∏Ç‡∏≤‡∏£‡∏±‡∏Å‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÉ‡∏î‡πÜ
            ‡πÇ‡∏õ‡∏£‡∏î‡πÉ‡∏ä‡πâ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏™‡πà‡∏ß‡∏ô‡∏ö‡∏∏‡∏Ñ‡∏Ñ‡∏•‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏Å‡∏é‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
          </p>
        </div>
      </div>
      <!-- FAQ Section (‡∏¢‡πâ‡∏≤‡∏¢‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å accordion) -->
      <div class="content-section">
        <h2>‚ÑπÔ∏è ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏û‡∏ö‡∏ö‡πà‡∏≠‡∏¢ (FAQ)</h2>
        <dl style="font-size: 0.9rem; color: var(--gray); line-height: 1.6">
          <dt>
            <strong>‡∏ñ‡∏≤‡∏°: Karaoke Processor ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÉ‡∏î‡∏ö‡πâ‡∏≤‡∏á?</strong>
          </dt>
          <dd>
            ‡∏ï‡∏≠‡∏ö: ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡πÄ‡∏ä‡πà‡∏ô Chrome, Edge, Firefox ‡πÅ‡∏•‡∏∞
            Safari (‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î)
          </dd>
          <dt><strong>‡∏ñ‡∏≤‡∏°: ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏≠‡∏ü‡πÑ‡∏•‡∏ô‡πå‡πÑ‡∏î‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?</strong></dt>
          <dd>
            ‡∏ï‡∏≠‡∏ö: ‡πÑ‡∏î‡πâ ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î‡∏≠‡∏≠‡∏ô‡πÑ‡∏•‡∏ô‡πå ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡πÄ‡∏Å‡πá‡∏ö cache
            ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏≠‡∏ü‡πÑ‡∏•‡∏ô‡πå‡πÑ‡∏î‡πâ‡∏ö‡∏≤‡∏á‡∏™‡πà‡∏ß‡∏ô
          </dd>
          <dt><strong>‡∏ñ‡∏≤‡∏°: ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?</strong></dt>
          <dd>‡∏ï‡∏≠‡∏ö: Karaoke Processor (Web) ‡πÄ‡∏õ‡πá‡∏ô‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ü‡∏£‡∏µ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ</dd>
          <dt>
            <strong
              >‡∏ñ‡∏≤‡∏°: ‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ‡πÉ‡∏ô‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?</strong
            >
          </dt>
          <dd>
            ‡∏ï‡∏≠‡∏ö: ‡πÑ‡∏°‡πà ‡∏ó‡∏∏‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÉ‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
          </dd>
          <dt>
            <strong>‡∏ñ‡∏≤‡∏°: ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏∞‡πÄ‡∏°‡∏¥‡∏î‡∏•‡∏¥‡∏Ç‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?</strong>
          </dt>
          <dd>
            ‡∏ï‡∏≠‡∏ö: ‡πÑ‡∏°‡πà
            ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ö‡∏∏‡∏Ñ‡∏Ñ‡∏•‡πÅ‡∏•‡∏∞‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏Å‡∏é‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
            ‡πÄ‡∏£‡∏≤‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏≤‡∏£‡∏û‡∏•‡∏¥‡∏Ç‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏Ñ‡∏£‡πà‡∏á‡∏Ñ‡∏£‡∏±‡∏î
          </dd>
        </dl>
      </div>
      <!-- Footer -->
      <div class="footer">
        <p>Made with ‚ù§Ô∏è by Next Karaoke Team</p>
        <p style="margin-top: 8px; opacity: 0.8">
          ¬© 2025 Next Karaoke. All rights reserved. |
          <a href="#">‡∏ô‡πÇ‡∏¢‡∏ö‡∏≤‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏±‡∏ß</a>
        </p>
      </div>
    </div>
    <script>
      let rootDirHandle = null;
      let isProcessing = false;
      let shouldStop = false;
      let worker = null;
      let db = null;
      const DB_NAME = "KaraokeProcessorDB";
      const DB_VERSION = 2;
      const STORE_RECORDS = "records";
      const STORE_BATCHES = "batches";
      const STORE_ARCHIVES = "archives";
      const elements = {
        selectFolderBtn: document.getElementById("selectFolderBtn"),
        inputInfo: document.getElementById("inputInfo"),
        startBtn: document.getElementById("startBtn"),
        stopBtn: document.getElementById("stopBtn"),
        statusText: document.getElementById("statusText"),
        progressFill: document.getElementById("progressFill"),
        logBox: document.getElementById("logBox"),
        batchSize: document.getElementById("batchSize"),
        zipSizeLimit: document.getElementById("zipSizeLimit"),
        cpuThrottle: document.getElementById("cpuThrottle"),
        createZips: document.getElementById("createZips"),
        createIndexZip: document.getElementById("createIndexZip"),
        performanceMode: document.getElementById("performanceMode"),
      };

      // Accordion logic
      const accordions = [
        { toggle: "settingsToggle", content: "settingsContent", arrow: true },
        { toggle: "aboutToggle", content: "aboutContent", arrow: true },
      ];
      accordions.forEach((acc) => {
        const toggle = document.getElementById(acc.toggle);
        const content = document.getElementById(acc.content);
        const arrow = toggle.querySelector(".accordion-arrow");
        toggle.addEventListener("click", () => {
          content.classList.toggle("closed");
          if (arrow) arrow.classList.toggle("closed");
        });
      });

      // ‡πÇ‡∏´‡∏•‡∏î AdSense ‡∏´‡∏•‡∏±‡∏á‡∏´‡∏ô‡πâ‡∏≤‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à
      window.addEventListener("load", () => {
        const adScript = document.createElement("script");
        adScript.async = true;
        adScript.src =
          "https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1343885117561998";
        adScript.crossOrigin = "anonymous";
        document.head.appendChild(adScript);
        adScript.onload = () => {
          try {
            (adsbygoogle = window.adsbygoogle || []).push({});
          } catch (e) {
            console.error("AdSense load error:", e);
          }
        };
      });

      function log(message, type = "info") {
        const timestamp = new Date().toLocaleTimeString("th-TH");
        const logEntry = document.createElement("div");
        logEntry.className = `log-entry log-${type}`;
        const timeSpan = document.createElement("span");
        timeSpan.className = "log-timestamp";
        timeSpan.textContent = `[${timestamp}]`;
        const messageSpan = document.createElement("span");
        messageSpan.className = "log-message";
        messageSpan.textContent = message;
        logEntry.appendChild(timeSpan);
        logEntry.appendChild(messageSpan);
        elements.logBox.appendChild(logEntry);
        elements.logBox.scrollTop = elements.logBox.scrollHeight;
        while (elements.logBox.children.length > 1000) {
          elements.logBox.removeChild(elements.logBox.firstChild);
        }
      }

      function updateProgress(percent) {
        const rounded = Math.round(percent);
        elements.progressFill.style.width = `${rounded}%`;
        elements.progressFill.textContent = `${rounded}%`;
      }

      function updateStatus(text) {
        elements.statusText.textContent = text;
      }

      async function initDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, DB_VERSION);
          request.onerror = (event) =>
            reject("IndexedDB error: " + event.target.error);
          request.onsuccess = (event) => {
            db = event.target.result;
            resolve(db);
          };
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_RECORDS)) {
              db.createObjectStore(STORE_RECORDS, { keyPath: "_id" });
            }
            if (!db.objectStoreNames.contains(STORE_BATCHES)) {
              db.createObjectStore(STORE_BATCHES, { keyPath: "_batchId" });
            }
            if (!db.objectStoreNames.contains(STORE_ARCHIVES)) {
              db.createObjectStore(STORE_ARCHIVES, { keyPath: "filename" });
            }
          };
        });
      }

      async function clearDBStore(storeName) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([storeName], "readwrite");
          const store = transaction.objectStore(storeName);
          const request = store.clear();
          request.onsuccess = resolve;
          request.onerror = (event) =>
            reject("Clear error: " + event.target.error);
        });
      }

      async function storeRecord(record, id) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_RECORDS], "readwrite");
          const store = transaction.objectStore(STORE_RECORDS);
          record._id = id;
          const request = store.put(record);
          request.onsuccess = resolve;
          request.onerror = (event) =>
            reject("Store error: " + event.target.error);
        });
      }

      async function getRecord(id) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_RECORDS]);
          const store = transaction.objectStore(STORE_RECORDS);
          const request = store.get(id);
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) =>
            reject("Get error: " + event.target.error);
        });
      }

      async function getRecordsCount() {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_RECORDS]);
          const store = transaction.objectStore(STORE_RECORDS);
          const request = store.count();
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) =>
            reject("Count error: " + event.target.error);
        });
      }

      async function storeBatch(batchId, batchData) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_BATCHES], "readwrite");
          const store = transaction.objectStore(STORE_BATCHES);
          const data = { _batchId: batchId, data: batchData };
          const request = store.put(data);
          request.onsuccess = resolve;
          request.onerror = (event) =>
            reject("Store batch error: " + event.target.error);
        });
      }

      async function getBatch(batchId) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_BATCHES]);
          const store = transaction.objectStore(STORE_BATCHES);
          const request = store.get(batchId);
          request.onsuccess = (event) => resolve(event.target.result?.data);
          request.onerror = (event) =>
            reject("Get batch error: " + event.target.error);
        });
      }

      async function getAllBatchKeys() {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_BATCHES]);
          const store = transaction.objectStore(STORE_BATCHES);
          const request = store.getAllKeys();
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) =>
            reject("Get keys error: " + event.target.error);
        });
      }

      async function storeArchive(filename, blob) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_ARCHIVES], "readwrite");
          const store = transaction.objectStore(STORE_ARCHIVES);
          const data = {
            filename,
            blob,
            size: blob.size,
            createdAt: new Date().toISOString(),
          };
          const request = store.put(data);
          request.onsuccess = resolve;
          request.onerror = (event) =>
            reject("Store archive error: " + event.target.error);
        });
      }

      async function getAllArchives() {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_ARCHIVES]);
          const store = transaction.objectStore(STORE_ARCHIVES);
          const request = store.getAll();
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) =>
            reject("Get archives error: " + event.target.error);
        });
      }

      async function deleteArchive(filename) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_ARCHIVES], "readwrite");
          const store = transaction.objectStore(STORE_ARCHIVES);
          const request = store.delete(filename);
          request.onsuccess = resolve;
          request.onerror = (event) =>
            reject("Delete archive error: " + event.target.error);
        });
      }

      async function clearArchives() {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_ARCHIVES], "readwrite");
          const store = transaction.objectStore(STORE_ARCHIVES);
          const request = store.clear();
          request.onsuccess = resolve;
          request.onerror = (event) =>
            reject("Clear archives error: " + event.target.error);
        });
      }

      async function renderDownloadSection() {
        let downloadSection = document.getElementById("downloadSection");
        if (!downloadSection) {
          downloadSection = document.createElement("div");
          downloadSection.id = "downloadSection";
          downloadSection.className = "card";
          downloadSection.innerHTML = `
            <div class="card-header">
              <h2>üì• ‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î</h2>
            </div>
            <div id="archiveList" style="margin-bottom: 15px;"></div>
            <button class="btn btn-danger" id="clearArchivesBtn">üóëÔ∏è ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</button>
          `;
          document
            .querySelector(".container")
            .insertBefore(downloadSection, document.querySelector(".footer"));
          document
            .getElementById("clearArchivesBtn")
            .addEventListener("click", async () => {
              await clearArchives();
              log("üßπ ‡∏•‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå archives ‡πÉ‡∏ô IndexedDB ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô", "info");
              renderArchiveList();
            });
        }
        renderArchiveList();
      }

      async function renderArchiveList() {
        const archives = await getAllArchives();
        const listContainer = document.getElementById("archiveList");
        listContainer.innerHTML = "";
        if (archives.length === 0) {
          listContainer.innerHTML =
            "<p style='text-align: center; color: var(--gray);'>‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ</p>";
          return;
        }
        archives.forEach((archive) => {
          const item = document.createElement("div");
          item.style =
            "display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid var(--border);";
          item.innerHTML = `
            <span>${archive.filename} (${(archive.size / 1024 / 1024).toFixed(
            2
          )} MB) - ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠ ${archive.createdAt}</span>
            <div>
              <button class="btn btn-primary" style="margin-right: 10px;" data-filename="${
                archive.filename
              }">‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î</button>
              <button class="btn btn-danger" data-filename="${
                archive.filename
              }">‡∏•‡∏ö</button>
            </div>
          `;
          item.querySelector(".btn-primary").addEventListener("click", () => {
            downloadFile(archive.blob, archive.filename);
          });
          item
            .querySelector(".btn-danger")
            .addEventListener("click", async () => {
              await deleteArchive(archive.filename);
              log(`üóëÔ∏è ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå ${archive.filename} ‡∏à‡∏≤‡∏Å IndexedDB`, "info");
              renderArchiveList();
            });
          listContainer.appendChild(item);
        });
      }

      function downloadFile(blob, filename) {
        try {
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          setTimeout(() => URL.revokeObjectURL(url), 100);
          log(`‚úÖ ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå ${filename} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`, "info");
        } catch (e) {
          log(`‚ùå Error downloading file ${filename}: ${e.message}`, "error");
        }
      }

      const workerCode = () => {
        self.importScripts(
          "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"
        );
        function parseDBFHeader(buffer) {
          try {
            const view = new DataView(buffer);
            const recordCount = view.getUint32(4, true);
            const headerLength = view.getUint16(8, true);
            const recordLength = view.getUint16(10, true);
            const fieldCount = Math.floor((headerLength - 32 - 1) / 32);
            const fields = [];
            let offset = 32;
            self.postMessage({
              action: "log",
              message: `‡πÄ‡∏£‡∏¥‡πà‡∏° parse DBF header: ${recordCount} records, ${fieldCount} fields`,
              type: "info",
            });
            for (let i = 0; i < fieldCount; i++) {
              const nameBytes = new Uint8Array(
                buffer.slice(offset, offset + 11)
              );
              const name = new TextDecoder("ascii")
                .decode(nameBytes)
                .replace(/\0/g, "")
                .trim();
              const type = String.fromCharCode(
                new Uint8Array(buffer.slice(offset + 11, offset + 12))[0]
              );
              const length = new Uint8Array(
                buffer.slice(offset + 16, offset + 17)
              )[0];
              fields.push({ name, type, length });
              offset += 32;
            }
            return { recordCount, headerLength, recordLength, fields };
          } catch (error) {
            self.postMessage({
              action: "error",
              message: `DBF Header Parsing Error: ${error.message} ‡∏ó‡∏µ‡πà offset ${
                offset || 0
              } | Stack: ${error.stack || "‡πÑ‡∏°‡πà‡∏°‡∏µ"}`,
              type: "error",
            });
            throw error;
          }
        }
        function tryDecode(bytes) {
          const encodings = ["windows-874", "utf-8"];
          for (const encoding of encodings) {
            try {
              return new TextDecoder(encoding).decode(bytes).trim();
            } catch (e) {
              self.postMessage({
                action: "log",
                message: `‚ö†Ô∏è Decoding ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö encoding ${encoding}: ${e.message}. ‡∏•‡∏≠‡∏á encoding ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ`,
                type: "warning",
              });
              continue;
            }
          }
          self.postMessage({
            action: "log",
            message: `‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ decode ‡πÑ‡∏î‡πâ‡∏´‡∏•‡∏±‡∏á‡∏•‡∏≠‡∏á‡∏ó‡∏∏‡∏Å encoding`,
            type: "warning",
          });
          return "[‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™‡πÑ‡∏î‡πâ]";
        }
        function parseDBFRecords(buffer, header) {
          try {
            const records = [];
            const dataStart = header.headerLength;
            const uint8Array = new Uint8Array(buffer);
            const startTime = Date.now();
            self.postMessage({
              action: "log",
              message: `‡πÄ‡∏£‡∏¥‡πà‡∏° parse ${header.recordCount} records ‡∏à‡∏≤‡∏Å offset ${dataStart}`,
              type: "info",
            });
            for (let i = 0; i < header.recordCount; i++) {
              const recordOffset = dataStart + i * header.recordLength;
              if (recordOffset + header.recordLength > buffer.byteLength) {
                self.postMessage({
                  action: "error",
                  message: `DBF Records Parsing Error: Offset ${recordOffset} ‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ç‡∏ô‡∏≤‡∏î buffer (${buffer.byteLength}) ‡∏ó‡∏µ‡πà record ${i}`,
                  type: "error",
                });
                break;
              }
              if (uint8Array[recordOffset] === 0x2a) continue;
              const record = {};
              let fieldOffset = recordOffset + 1;
              for (const field of header.fields) {
                const fieldBytes = uint8Array.slice(
                  fieldOffset,
                  fieldOffset + field.length
                );
                try {
                  record[field.name] = tryDecode(fieldBytes);
                } catch (e) {
                  self.postMessage({
                    action: "log",
                    message: `‚ö†Ô∏è Decoding ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö field ${field.name} ‡πÉ‡∏ô record ${i}: ${e.message}. ‡πÉ‡∏ä‡πâ fallback "[‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™‡πÑ‡∏î‡πâ]"`,
                    type: "warning",
                  });
                  record[field.name] = "[‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™‡πÑ‡∏î‡πâ]";
                }
                fieldOffset += field.length;
              }
              records.push(record);
              if (i % 500 === 0) {
                const elapsed = (Date.now() - startTime) / 1000;
                self.postMessage({
                  action: "log",
                  message: `‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• ${i} ‡∏à‡∏≤‡∏Å ${
                    header.recordCount
                  } records (‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤ ${elapsed.toFixed(2)} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)`,
                  type: "info",
                });
                self.postMessage({
                  action: "progress",
                  message: Math.round((i / header.recordCount) * 100),
                });
                if (i % 5000 === 0) {
                  self.postMessage({
                    action: "log",
                    message: `‡∏´‡∏¢‡∏∏‡∏î‡∏û‡∏±‡∏Å‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß 100ms ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô CPU`,
                    type: "info",
                  });
                  setTimeout(() => {}, 100);
                }
              }
            }
            const totalElapsed = (Date.now() - startTime) / 1000;
            self.postMessage({
              action: "log",
              message: `‚úÖ ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô‡∏Å‡∏≤‡∏£ parse ${
                records.length
              } records ‡πÉ‡∏ô ${totalElapsed.toFixed(2)} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ`,
              type: "info",
            });
            return records;
          } catch (error) {
            self.postMessage({
              action: "error",
              message: `DBF Records Parsing Error: ${
                error.message
              } ‡∏ó‡∏µ‡πà record ${i || 0} | Stack: ${error.stack || "‡πÑ‡∏°‡πà‡∏°‡∏µ"}`,
              type: "error",
            });
            throw error;
          }
        }
        async function createMIDIZip(midi, lyr, cur, performanceMode) {
          try {
            const zip = new JSZip();
            zip.file("song.mid", midi);
            zip.file("song.lyr", lyr);
            zip.file("song.cur", cur);
            self.postMessage({
              action: "log",
              message: `‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á MIDI ZIP (performanceMode: ${performanceMode})`,
              type: "info",
            });
            const zipData = await zip.generateAsync({
              type: "uint8array",
              compression: performanceMode ? "DEFLATE" : "DEFLATE",
              compressionOptions: performanceMode ? { level: 1 } : { level: 6 },
            });
            self.postMessage({
              action: "log",
              message: `‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á MIDI ZIP ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (${(
                zipData.length / 1024
              ).toFixed(2)} KB)`,
              type: "info",
            });
            return zipData;
          } catch (error) {
            self.postMessage({
              action: "error",
              message: `MIDI ZIP Creation Error: ${error.message} | Stack: ${
                error.stack || "‡πÑ‡∏°‡πà‡∏°‡∏µ"
              }`,
              type: "error",
            });
            throw error;
          }
        }
        async function buildSearchIndex(records) {
          try {
            self.postMessage({
              action: "log",
              message: `‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏™‡∏£‡πâ‡∏≤‡∏á search index ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${records.length} records`,
              type: "info",
            });
            const wordMap = {};
            const chunks = {};
            let chunkId = 0;
            let currentChunk = {};
            let currentChunkSize = 0;
            const MAX_CHUNK_SIZE = 5 * 1024 * 1024;
            function extractWords(text) {
              return (text.match(/[a-zA-Z\d\u0e00-\u0e7f]+/g) || [])
                .map((w) => w.toLowerCase())
                .filter((w) => w.length > 1);
            }
            for (const record of records) {
              if (
                record._originalIndex === undefined ||
                record._superIndex === undefined
              )
                continue;
              const preview = {
                t: record.TITLE || "",
                a: record.ARTIST || "",
                i: record._originalIndex,
                s: record._superIndex,
              };
              const text = `${record.TITLE} ${record.ARTIST}`;
              const words = extractWords(text);
              for (const word of words) {
                if (!wordMap[word]) wordMap[word] = [];
                wordMap[word].push(preview);
              }
            }
            const sortedWords = Object.keys(wordMap).sort();
            const wordToChunk = {};
            for (const word of sortedWords) {
              const entrySize = JSON.stringify(wordMap[word]).length;
              if (
                currentChunkSize + entrySize > MAX_CHUNK_SIZE &&
                Object.keys(currentChunk).length > 0
              ) {
                chunks[chunkId] = currentChunk;
                chunkId++;
                currentChunk = {};
                currentChunkSize = 0;
              }
              currentChunk[word] = wordMap[word];
              wordToChunk[word] = chunkId;
              currentChunkSize += entrySize;
            }
            if (Object.keys(currentChunk).length > 0) {
              chunks[chunkId] = currentChunk;
            }
            const masterIndex = {
              totalRecords: records.length,
              words: sortedWords,
              wordToChunkMap: wordToChunk,
              buildTime: Date.now(),
              lastBuilt: new Date().toISOString(),
            };
            self.postMessage({
              action: "log",
              message: `‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á search index ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô: ${
                Object.keys(chunks).length
              } chunks`,
              type: "info",
            });
            return { masterIndex, chunks };
          } catch (error) {
            self.postMessage({
              action: "error",
              message: `Search Index Building Error: ${
                error.message
              } | Stack: ${error.stack || "‡πÑ‡∏°‡πà‡∏°‡∏µ"}`,
              type: "error",
            });
            throw error;
          }
        }
        self.onmessage = async (e) => {
          try {
            const { action, data } = e.data;
            if (action === "parseDBF") {
              const header = parseDBFHeader(data.buffer);
              const records = parseDBFRecords(data.buffer, header);
              self.postMessage({ action: "parseDBFResult", header, records });
            } else if (action === "createMIDIZip") {
              const zipData = await createMIDIZip(
                data.midi,
                data.lyr,
                data.cur,
                data.performanceMode
              );
              self.postMessage({ action: "createMIDIZipResult", zipData });
            } else if (action === "buildSearchIndex") {
              const indexData = await buildSearchIndex(data.records);
              self.postMessage({ action: "buildSearchIndexResult", indexData });
            }
          } catch (error) {
            self.postMessage({
              action: "error",
              message: `Worker Error: ${error.message} | Stack: ${
                error.stack || "‡πÑ‡∏°‡πà‡∏°‡∏µ"
              }`,
              type: "error",
            });
          }
        };
      };
      const blob = new Blob([`(${workerCode.toString()})()`], {
        type: "application/javascript",
      });
      const workerURL = URL.createObjectURL(blob);
      worker = new Worker(workerURL);
      worker.onmessage = (e) => {
        const { action, message, header, records, zipData, indexData, type } =
          e.data;
        if (action === "parseDBFResult") {
          workerParseDBFResult(header, records);
        } else if (action === "createMIDIZipResult") {
          workerCreateMIDIZipResult(zipData);
        } else if (action === "buildSearchIndexResult") {
          workerBuildSearchIndexResult(indexData);
        } else if (action === "log") {
          log(message, type);
        } else if (action === "progress") {
          updateStatus(`‡∏Å‡∏≥‡∏•‡∏±‡∏á parse ‡πÑ‡∏ü‡∏•‡πå DBF: ${message}%`);
        } else if (action === "error") {
          log(`‚ùå Worker Error: ${message}`, "error");
          updateStatus("‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô Worker");
          isProcessing = false;
          elements.startBtn.disabled = false;
          elements.stopBtn.disabled = true;
        }
      };

      async function getFileByPath(pathParts) {
        const fullPath = pathParts.join("/");
        try {
          if (rootDirHandle) {
            let currentHandle = rootDirHandle;
            for (let i = 0; i < pathParts.length - 1; i++) {
              currentHandle = await currentHandle.getDirectoryHandle(
                pathParts[i],
                {
                  create: false,
                }
              );
            }
            const fileName = pathParts[pathParts.length - 1];
            const fileHandle = await currentHandle.getFileHandle(fileName);
            const file = await fileHandle.getFile();
            return { arrayBuffer: () => file.arrayBuffer() };
          }
          return null;
        } catch (e) {
          log(`‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå ${fullPath}: ${e.message}`, "warning");
          return null;
        }
      }

      async function getSongFiles(track) {
        if (!track.CODE || !track.TYPE || !track.SUB_TYPE) {
          log(`‚ö†Ô∏è Track ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö: ${JSON.stringify(track)}`, "warning");
          return null;
        }
        const code = track.CODE;
        const folder = code[0];
        const primaryPath = ["Songs", track.TYPE, track.SUB_TYPE];
        try {
          if (track.SUB_TYPE === "EMK") {
            let emkFile = await getFileByPath([
              ...primaryPath,
              folder,
              `${code}.emk`,
            ]);
            if (!emkFile) {
              emkFile = await getFileByPath([...primaryPath, `${code}.emk`]);
            }
            if (emkFile) {
              log(`‚úÖ ‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå EMK: ${code}.emk`, "info");
              return { emk: await emkFile.arrayBuffer() };
            }
          } else if (track.SUB_TYPE === "NCN") {
            const [midiFile, lyrFile, curFile] = await Promise.all([
              getFileByPath([...primaryPath, "Song", folder, `${code}.mid`]) ||
                getFileByPath([...primaryPath, "Song", `${code}.mid`]),
              getFileByPath([
                ...primaryPath,
                "Lyrics",
                folder,
                `${code}.lyr`,
              ]) || getFileByPath([...primaryPath, "Lyrics", `${code}.lyr`]),
              getFileByPath([
                ...primaryPath,
                "Cursor",
                folder,
                `${code}.cur`,
              ]) || getFileByPath([...primaryPath, "Cursor", `${code}.cur`]),
            ]);
            if (midiFile && lyrFile && curFile) {
              const [midi, lyr, cur] = await Promise.all([
                midiFile.arrayBuffer(),
                lyrFile.arrayBuffer(),
                curFile.arrayBuffer(),
              ]);
              log(`‚úÖ ‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå NCN: ${code}.mid, .lyr, .cur`, "info");
              return { midi, lyr, cur };
            }
          }
          log(`‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö track ${code}`, "warning");
          return null;
        } catch (e) {
          log(
            `‚ùå Error fetching song files for ${code}: ${e.message} | Stack: ${
              e.stack || "‡πÑ‡∏°‡πà‡∏°‡∏µ"
            }`,
            "error"
          );
          return null;
        }
      }

      let workerParseDBFResultResolve = null;
      let workerCreateMIDIZipResultResolve = null;
      let workerBuildSearchIndexResultResolve = null;

      function workerParseDBFResult(header, records) {
        if (workerParseDBFResultResolve) {
          workerParseDBFResultResolve({ header, records });
          workerParseDBFResultResolve = null;
        }
      }

      function workerCreateMIDIZipResult(zipData) {
        if (workerCreateMIDIZipResultResolve) {
          workerCreateMIDIZipResultResolve(zipData);
          workerCreateMIDIZipResultResolve = null;
        }
      }

      function workerBuildSearchIndexResult(indexData) {
        if (workerBuildSearchIndexResultResolve) {
          workerBuildSearchIndexResultResolve(indexData);
          workerBuildSearchIndexResultResolve = null;
        }
      }

      async function parseDBF(buffer) {
        return new Promise((resolve, reject) => {
          workerParseDBFResultResolve = resolve;
          worker.postMessage({ action: "parseDBF", data: { buffer } });
          setTimeout(
            () =>
              reject(
                new Error(
                  "DBF parsing timeout ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å 10 ‡∏ô‡∏≤‡∏ó‡∏µ: ‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏≤‡∏à‡πÉ‡∏´‡∏ç‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ä‡πâ‡∏≤"
                )
              ),
            600000
          );
        });
      }

      async function createMIDIZip(midi, lyr, cur, performanceMode) {
        return new Promise((resolve, reject) => {
          workerCreateMIDIZipResultResolve = resolve;
          worker.postMessage({
            action: "createMIDIZip",
            data: { midi, lyr, cur, performanceMode },
          });
          setTimeout(
            () => reject(new Error("MIDI ZIP creation timeout")),
            10000
          );
        });
      }

      async function buildSearchIndex(records) {
        return new Promise((resolve, reject) => {
          workerBuildSearchIndexResultResolve = resolve;
          worker.postMessage({ action: "buildSearchIndex", data: { records } });
          setTimeout(
            () => reject(new Error("Search index building timeout")),
            60000
          );
        });
      }

      const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

      async function processKaraoke() {
        shouldStop = false;
        isProcessing = true;
        try {
          await initDB();
          await clearDBStore(STORE_RECORDS);
          await clearDBStore(STORE_BATCHES);
          if (!rootDirHandle) {
            throw new Error("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏Å‡πà‡∏≠‡∏ô");
          }
          updateStatus("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå SONG.DBF...");
          log("üìñ ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå Data/SONG.DBF", "info");
          const dbfFile = await getFileByPath(["Data", "SONG.DBF"]);
          if (!dbfFile) {
            throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå Data/SONG.DBF ‡πÉ‡∏ô‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å");
          }
          const dbfBuffer = await dbfFile.arrayBuffer();
          updateProgress(5);
          log(
            `‚úÖ ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå SONG.DBF ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (${(
              dbfBuffer.byteLength /
              1024 /
              1024
            ).toFixed(2)} MB)`,
            "info"
          );
          updateStatus("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á DBF...");
          log("üîç ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå DBF header...", "info");
          let { header, records } = await parseDBF(dbfBuffer);
          log(
            `‚úÖ ‡∏û‡∏ö ${header.recordCount} records, ${header.fields.length} fields`,
            "info"
          );
          updateProgress(10);
          updateStatus("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...");
          log(`üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å ${records.length} records ‡∏•‡∏á IndexedDB...`, "info");
          for (let i = 0; i < records.length; i++) {
            await storeRecord(records[i], i);
            if (i % 1000 === 0) {
              updateStatus(`‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å record ${i}/${records.length}`);
            }
          }
          records = null;
          updateProgress(15);
          if (shouldStop) throw new Error("‡∏´‡∏¢‡∏∏‡∏î‡πÇ‡∏î‡∏¢‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ");
          const config = {
            batchSize: parseInt(elements.batchSize.value),
            zipSizeLimit: parseInt(elements.zipSizeLimit.value) * 1024 * 1024,
            cpuThrottle: parseInt(elements.cpuThrottle.value),
            createZips: elements.createZips.checked,
            createIndexZip: elements.createIndexZip.checked,
            performanceMode: elements.performanceMode.checked,
          };
          log(
            `‚öôÔ∏è ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤: Batch=${config.batchSize}, ZIP Limit=${(
              config.zipSizeLimit /
              1024 /
              1024
            ).toFixed(0)}MB, Throttle=${config.cpuThrottle}ms, Performance=${
              config.performanceMode
            }`,
            "info"
          );
          updateStatus("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏û‡∏•‡∏á...");
          const totalRecords = await getRecordsCount();
          let successCount = 0;
          let currentBatch = [];
          let currentBatchZip = config.createZips ? new JSZip() : null;
          let currentBatchSize = 0;
          let batchIndex = 0;
          const parallelBatchSize = config.performanceMode ? 50 : 20;
          const compressionLevel = config.performanceMode ? 1 : 3;
          for (let i = 0; i < totalRecords; i += parallelBatchSize) {
            if (shouldStop) throw new Error("‡∏´‡∏¢‡∏∏‡∏î‡πÇ‡∏î‡∏¢‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ");
            const end = Math.min(i + parallelBatchSize, totalRecords);
            const batchPromises = [];
            for (let j = i; j < end; j++) {
              batchPromises.push(
                (async () => {
                  const track = await getRecord(j);
                  if (!track) {
                    log(`‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö record ‡∏ó‡∏µ‡πà index ${j}`, "warning");
                    return null;
                  }
                  try {
                    const files = await getSongFiles(track);
                    if (!files) return null;
                    let content = null;
                    let filename = "";
                    if (
                      track.SUB_TYPE === "NCN" &&
                      files.midi &&
                      files.lyr &&
                      files.cur
                    ) {
                      updateStatus(`‡∏™‡∏£‡πâ‡∏≤‡∏á ZIP ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö track ${j} (NCN)`);
                      const zip = new JSZip();
                      zip.file("song.mid", files.midi);
                      zip.file("song.lyr", files.lyr);
                      zip.file("song.cur", files.cur);
                      content = await zip.generateAsync({
                        type: "uint8array",
                        compression: "DEFLATE",
                        compressionOptions: { level: compressionLevel },
                      });
                      filename = `${j}.zip`;
                    } else if (track.SUB_TYPE === "EMK" && files.emk) {
                      content = new Uint8Array(files.emk);
                      filename = `${j}.emk`;
                    }
                    track._originalIndex = j;
                    track._superIndex = batchIndex;
                    await storeRecord(track, j);
                    successCount++;
                    return { trackId: j, content, filename };
                  } catch (e) {
                    log(
                      `‚ùå Error processing track ${j}: ${e.message} | Stack: ${
                        e.stack || "‡πÑ‡∏°‡πà‡∏°‡∏µ"
                      }`,
                      "error"
                    );
                    return null;
                  }
                })()
              );
            }
            const results = await Promise.all(batchPromises);
            results.forEach((result) => {
              if (result && result.content) {
                currentBatch.push(result);
                if (config.createZips && currentBatchZip) {
                  currentBatchZip.file(result.filename, result.content);
                  currentBatchSize += result.content.length;
                }
              }
            });
            if (
              currentBatch.length >= config.batchSize ||
              (config.createZips && currentBatchSize >= config.zipSizeLimit)
            ) {
              if (config.createZips && currentBatchZip) {
                updateStatus(`‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å batch ${batchIndex}...`);
                log(
                  `üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å batch ${batchIndex}: ${
                    currentBatch.length
                  } ‡πÄ‡∏û‡∏•‡∏á (${(currentBatchSize / 1024 / 1024).toFixed(2)}MB)`,
                  "info"
                );
                const batchData = await currentBatchZip.generateAsync({
                  type: "uint8array",
                  compression: config.performanceMode ? "DEFLATE" : "DEFLATE",
                  compressionOptions: config.performanceMode
                    ? { level: 1 }
                    : { level: 6 },
                });
                await storeBatch(batchIndex, batchData);
                currentBatchZip = null;
              }
              batchIndex++;
              currentBatch = [];
              currentBatchZip = config.createZips ? new JSZip() : null;
              currentBatchSize = 0;
            }
            const progress = 15 + Math.floor((end / totalRecords) * 70);
            updateProgress(progress);
            updateStatus(`‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏û‡∏•‡∏á: ${successCount}/${totalRecords}`);
            log(
              `‚è≥ ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•: ${successCount}/${totalRecords} (${end} records)`,
              "info"
            );
            if (
              (i % 100 === 0 || end >= totalRecords) &&
              config.cpuThrottle > 0
            ) {
              await sleep(
                config.performanceMode
                  ? Math.min(config.cpuThrottle, 1)
                  : config.cpuThrottle
              );
            }
          }
          if (currentBatch.length > 0 && config.createZips && currentBatchZip) {
            updateStatus(`‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å batch ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ ${batchIndex}...`);
            log(
              `üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å batch ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ ${batchIndex}: ${currentBatch.length} ‡πÄ‡∏û‡∏•‡∏á`,
              "info"
            );
            const batchData = await currentBatchZip.generateAsync({
              type: "uint8array",
              compression: config.performanceMode ? "DEFLATE" : "DEFLATE",
              compressionOptions: config.performanceMode
                ? { level: 1 }
                : { level: 6 },
            });
            await storeBatch(batchIndex, batchData);
            currentBatchZip = null;
          }
          updateProgress(85);
          log(
            `‚úÖ ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏û‡∏•‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à: ${successCount} ‡∏à‡∏≤‡∏Å ${totalRecords} records`,
            "info"
          );
          if (config.createZips) {
            updateStatus("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ü‡∏•‡πå karaoke_*.zip ‡∏•‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...");
            log("üì¶ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å karaoke archives ‡∏•‡∏á IndexedDB...", "info");
            let archiveIndex = 0;
            let currentArchive = new JSZip();
            let currentArchiveSize = 0;
            const batchKeys = await getAllBatchKeys();
            for (const batchId of batchKeys.sort((a, b) => a - b)) {
              const batchData = await getBatch(batchId);
              if (
                currentArchiveSize + batchData.length > config.zipSizeLimit &&
                currentArchiveSize > 0
              ) {
                updateStatus(`‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å karaoke_${archiveIndex}.zip...`);
                const archiveData = await currentArchive.generateAsync({
                  type: "blob",
                  compression: config.performanceMode ? "DEFLATE" : "DEFLATE",
                  compressionOptions: config.performanceMode
                    ? { level: 1 }
                    : { level: 6 },
                });
                await storeArchive(`karaoke_${archiveIndex}.zip`, archiveData);
                log(
                  `‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å karaoke_${archiveIndex}.zip ‡∏•‡∏á IndexedDB (${(
                    archiveData.size /
                    1024 /
                    1024
                  ).toFixed(2)}MB)`,
                  "info"
                );
                archiveIndex++;
                currentArchive = new JSZip();
                currentArchiveSize = 0;
              }
              currentArchive.file(`${batchId}.zip`, batchData);
              currentArchiveSize += batchData.length;
            }
            if (currentArchiveSize > 0) {
              updateStatus(`‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å karaoke_${archiveIndex}.zip...`);
              const archiveData = await currentArchive.generateAsync({
                type: "blob",
                compression: config.performanceMode ? "DEFLATE" : "DEFLATE",
                compressionOptions: { level: config.performanceMode ? 1 : 6 },
              });
              await storeArchive(`karaoke_${archiveIndex}.zip`, archiveData);
              log(
                `‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å karaoke_${archiveIndex}.zip ‡∏•‡∏á IndexedDB (${(
                  archiveData.size /
                  1024 /
                  1024
                ).toFixed(2)}MB)`,
                "info"
              );
            }
          }
          updateProgress(95);
          if (config.createIndexZip) {
            updateStatus("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å index.zip ‡∏•‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...");
            log("üîç ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å search index ‡∏•‡∏á IndexedDB...", "info");
            const recordsForIndex = [];
            const total = await getRecordsCount();
            const indexBatchSize = 500;
            for (let i = 0; i < total; i += indexBatchSize) {
              const end = Math.min(i + indexBatchSize, total);
              for (let j = i; j < end; j++) {
                const record = await getRecord(j);
                if (record) recordsForIndex.push(record);
              }
            }
            const { masterIndex, chunks } = await buildSearchIndex(
              recordsForIndex
            );
            const indexZip = new JSZip();
            indexZip.file("master.json", JSON.stringify(masterIndex));
            for (const chunkId in chunks) {
              indexZip.file(
                `chunk_${chunkId}.json`,
                JSON.stringify(chunks[chunkId])
              );
            }
            const indexZipData = await indexZip.generateAsync({ type: "blob" });
            await storeArchive("index.zip", indexZipData);
            log(
              `‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å index.zip ‡∏•‡∏á IndexedDB (${(
                indexZipData.size / 1024
              ).toFixed(2)}KB)`,
              "info"
            );
          }
          updateProgress(100);
          updateStatus("üéâ ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•! ‡πÑ‡∏ü‡∏•‡πå‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á");
          log("üéâ ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå! ‡πÑ‡∏ü‡∏•‡πå‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•", "info");
          await renderDownloadSection();
        } catch (error) {
          if (error.message === "‡∏´‡∏¢‡∏∏‡∏î‡πÇ‡∏î‡∏¢‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ") {
            log("‚èπÔ∏è ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏´‡∏¢‡∏∏‡∏î‡∏•‡∏á‡∏ï‡∏≤‡∏°‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ", "warning");
            updateStatus("‚èπÔ∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß");
          } else {
            log(
              `‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏£‡πâ‡∏≤‡∏¢‡πÅ‡∏£‡∏á: ${error.message} | Stack: ${
                error.stack || "‡πÑ‡∏°‡πà‡∏°‡∏µ stack trace"
              }`,
              "error"
            );
            if (error.message.includes("DBF parsing timeout")) {
              log(
                "‚ö†Ô∏è ‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏õ‡πÑ‡∏î‡πâ: ‡πÑ‡∏ü‡∏•‡πå SONG.DBF ‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ (‡∏à‡∏≥‡∏ô‡∏ß‡∏ô records ‡πÄ‡∏¢‡∏≠‡∏∞‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏ü‡∏•‡πå >100MB). ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥: ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á‡∏Ç‡∏∂‡πâ‡∏ô, ‡πÄ‡∏û‡∏¥‡πà‡∏° CPU Throttle, ‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏ö‡πà‡∏á‡πÑ‡∏ü‡∏•‡πå DBF ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏¢‡πà‡∏≠‡∏¢‡πÜ.",
                "warning"
              );
            } else if (error.message.includes("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå")) {
              log(
                "‚ö†Ô∏è ‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏õ‡πÑ‡∏î‡πâ: ‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå SONG.DBF ‡∏´‡∏£‡∏∑‡∏≠‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á. ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á.",
                "warning"
              );
            } else {
              log(
                "‚ö†Ô∏è ‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏õ‡πÑ‡∏î‡πâ: ‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢, ‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö, ‡∏´‡∏£‡∏∑‡∏≠‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠. ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ Chrome ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô.",
                "warning"
              );
            }
            updateStatus(`‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ${error.message}`);
          }
        } finally {
          isProcessing = false;
          elements.startBtn.disabled = false;
          elements.stopBtn.disabled = true;
          await clearDBStore(STORE_RECORDS);
          await clearDBStore(STORE_BATCHES);
          log("üßπ ‡∏•‡πâ‡∏≤‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• IndexedDB ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô", "info");
        }
      }

      elements.selectFolderBtn.addEventListener("click", async () => {
        if ("showDirectoryPicker" in window) {
          try {
            const handle = await window.showDirectoryPicker();
            rootDirHandle = handle;
            elements.inputInfo.textContent = `üìÅ ‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå: ${handle.name}`;
            elements.inputInfo.classList.add("active");
            log(`üìÅ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå: ${handle.name}`, "info");
          } catch (err) {
            log(`‚ö†Ô∏è ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå: ${err.message}`, "warning");
            updateStatus("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå");
          }
        } else {
          log(
            "‚ùå ‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö File System Access API (‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ Chrome 86+ ‡∏´‡∏£‡∏∑‡∏≠ Edge 86+)",
            "error"
          );
          updateStatus("‚ùå ‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö API");
          alert("‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö File System Access API");
        }
      });

      elements.startBtn.addEventListener("click", () => {
        if (!rootDirHandle) {
          log("‚ö†Ô∏è ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•", "warning");
          updateStatus("‚ö†Ô∏è ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå");
          return;
        }
        if (isProcessing) {
          log("‚ö†Ô∏è ‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•", "warning");
          return;
        }
        elements.logBox.innerHTML = "";
        elements.startBtn.disabled = true;
        elements.stopBtn.disabled = false;
        updateProgress(0);
        updateStatus("‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...");
        log("üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞", "info");
        processKaraoke();
      });

      elements.stopBtn.addEventListener("click", () => {
        if (isProcessing) {
          shouldStop = true;
          log("‚èπÔ∏è ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•", "warning");
          updateStatus("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏´‡∏¢‡∏∏‡∏î...");
          elements.stopBtn.disabled = true;
        }
      });

      // ‡πÇ‡∏´‡∏•‡∏î archives ‡∏ó‡∏µ‡πà‡∏Ñ‡πâ‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏≠‡∏ô‡πÄ‡∏õ‡∏¥‡∏î‡∏´‡∏ô‡πâ‡∏≤
      window.addEventListener("load", async () => {
        await initDB();
        const archives = await getAllArchives();
        if (archives.length > 0) {
          renderDownloadSection();
          log(
            `üîÑ ‡∏û‡∏ö ${archives.length} ‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡πâ‡∏≤‡∏á‡πÑ‡∏ß‡πâ‡∏à‡∏≤‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏Å‡πà‡∏≠‡∏ô`,
            "info"
          );
        }
      });
    </script>
  </body>
</html>
