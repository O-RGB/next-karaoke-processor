<!DOCTYPE html>
<html lang="th">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡∏ü‡∏£‡∏µ ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö .EMK, .DBF ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏° ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏ß‡πá‡∏ö‡πÑ‡∏î‡πâ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ"
    />
    <script
      async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1343885117561998"
      crossorigin="anonymous"
    ></script>
    <meta
      name="keywords"
      content="‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞, EMK converter, DBF converter, karaoke converter ‡πÑ‡∏ó‡∏¢, ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡∏ü‡∏£‡∏µ"
    />
    <title>Next Karaoke Processor - ‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡∏ü‡∏£‡∏µ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --primary: #6366f1;
        --primary-dark: #4f46e5;
        --secondary: #8b5cf6;
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --dark: #1e293b;
        --light: #f8fafc;
        --gray: #64748b;
        --border: #e2e8f0;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
        color: var(--dark);
      }

      .container {
        max-width: 800px; /* ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ compact ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô */
        margin: 0 auto;
      }

      .hero {
        text-align: center;
        color: white;
        margin-bottom: 30px;
        animation: fadeInDown 0.8s ease-out;
      }

      .hero h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }

      .hero .subtitle {
        font-size: 1.1rem;
        opacity: 0.9;
        margin-bottom: 15px;
      }

      .hero .features {
        display: flex;
        justify-content: center;
        gap: 20px;
        flex-wrap: wrap;
        margin-top: 15px;
      }

      .feature-badge {
        background: rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
        padding: 8px 16px;
        border-radius: 50px;
        font-size: 0.85rem;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .card {
        background: white;
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 15px 45px rgba(0, 0, 0, 0.25);
        margin-bottom: 15px;
        animation: fadeInUp 0.8s ease-out;
      }

      .card-header {
        border-bottom: 2px solid var(--border);
        padding-bottom: 15px;
        margin-bottom: 20px;
      }

      .card-header h2 {
        color: var(--primary);
        font-size: 1.5rem;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .alert {
        background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
        border-left: 4px solid var(--warning);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        line-height: 1.5;
        font-size: 0.9rem;
      }

      .alert strong {
        display: block;
        margin-bottom: 8px;
        color: #92400e;
      }

      .form-section {
        margin-bottom: 15px;
      }

      .form-section label {
        display: block;
        font-weight: 600;
        margin-bottom: 8px;
        color: var(--dark);
        font-size: 0.9rem;
      }

      .btn-group {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 6px;
        flex: 1;
        justify-content: center;
        min-width: 120px;
      }

      .btn-primary {
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--secondary) 100%
        );
        color: white;
      }

      .btn-primary:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(99, 102, 241, 0.3);
      }

      .btn-success {
        background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
        color: white;
      }

      .btn-success:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(16, 185, 129, 0.3);
      }

      .btn-danger {
        background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
        color: white;
      }

      .btn-danger:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(239, 68, 68, 0.3);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .file-info {
        background: var(--light);
        padding: 12px 16px;
        border-radius: 8px;
        margin-top: 10px;
        border: 2px dashed var(--border);
        text-align: center;
        color: var(--gray);
        font-weight: 500;
        font-size: 0.9rem;
      }

      .file-info.active {
        background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
        border-color: var(--primary);
        color: var(--primary-dark);
      }

      input[type="number"] {
        width: 100%;
        padding: 10px 14px;
        border: 2px solid var(--border);
        border-radius: 8px;
        font-size: 0.95rem;
        transition: all 0.3s ease;
      }

      input[type="number"]:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
      }

      .checkbox-group {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 12px;
        background: var(--light);
        border-radius: 8px;
        margin-bottom: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.9rem;
      }

      .checkbox-group:hover {
        background: #e0e7ff;
      }

      .checkbox-group input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--primary);
      }

      .checkbox-group label {
        cursor: pointer;
        margin: 0;
        flex: 1;
      }

      .progress-section {
        margin-top: 20px;
      }

      .status {
        text-align: center;
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: 15px;
        color: var(--primary);
        padding: 12px;
        background: var(--light);
        border-radius: 8px;
      }

      .progress-bar {
        width: 100%;
        height: 30px;
        background: var(--light);
        border-radius: 15px;
        overflow: hidden;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 15px;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(
          90deg,
          var(--primary) 0%,
          var(--secondary) 100%
        );
        transition: width 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 600;
        font-size: 0.85rem;
      }

      .log-box {
        background: #1e293b;
        border-radius: 8px;
        padding: 10px;
        min-height: 250px;
        max-height: 250px;
        overflow-y: auto;
        font-family: "Courier New", monospace;
        font-size: 0.8rem;
        box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.5);
      }

      .log-entry {
        padding: 3px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .log-entry:last-child {
        border-bottom: none;
      }

      .log-timestamp {
        color: #94a3b8;
        margin-right: 8px;
      }

      .log-message {
        color: #e2e8f0;
      }

      .log-info .log-message {
        color: #60a5fa;
      }

      .log-warning .log-message {
        color: #fbbf24;
      }

      .log-error .log-message {
        color: #f87171;
      }

      .settings-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 15px;
      }

      .footer {
        text-align: center;
        color: white;
        margin-top: 30px;
        padding: 15px;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 10px;
        font-size: 0.85rem;
      }

      .footer a {
        color: white;
        text-decoration: none;
        font-weight: 600;
      }

      .footer a:hover {
        text-decoration: underline;
      }

      .accordion {
        margin-bottom: 15px;
      }

      .accordion-header {
        background: var(--light);
        padding: 12px 15px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        color: var(--primary);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .accordion-content {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease;
        padding: 0px;
        background: #fff;
        border-radius: 10px;
        margin-top: 0px;
        opacity: 0;
      }

      .accordion-content.open {
        max-height: 1000px;
        opacity: 1;
        margin-top: 5px;
        padding: 15px;
      }

      .accordion-arrow {
        transition: transform 0.3s ease;
      }

      .accordion-arrow.open {
        transform: rotate(180deg);
      }

      @keyframes fadeInDown {
        from {
          opacity: 0;
          transform: translateY(-20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(-10px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      @media (max-width: 768px) {
        .hero h1 {
          font-size: 1.8rem;
        }

        .hero .subtitle {
          font-size: 0.95rem;
        }

        .hero .features {
          gap: 10px;
        }

        .feature-badge {
          font-size: 0.75rem;
          padding: 6px 12px;
        }

        .card {
          padding: 15px;
        }

        .btn-group {
          flex-direction: column;
        }

        .btn {
          width: 100%;
        }

        .settings-grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Hero Section -->
      <div class="hero">
        <h1>üé§ Next Karaoke Processor</h1>
        <p class="subtitle">
          ‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡∏ü‡∏£‡∏µ ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°
          ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ö‡∏∏‡∏Ñ‡∏Ñ‡∏•‡πÅ‡∏•‡∏∞‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏Å‡∏é‡∏´‡∏°‡∏≤‡∏¢‡∏•‡∏¥‡∏Ç‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå
        </p>
        <div class="features">
          <div class="feature-badge">‚úì ‡∏ü‡∏£‡∏µ 100%</div>
          <div class="feature-badge">‚úì ‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢</div>
          <div class="feature-badge">‚úì ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢</div>
          <div class="feature-badge">‚úì ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö EMK, DBF</div>
        </div>
      </div>

      <!-- Main Card -->
      <div class="card">
        <div class="card-header">
          <h2>üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô</h2>
        </div>

        <!-- Warning Alert -->
        <div class="alert">
          <strong>‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:</strong>
          ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö File System Access API (Chrome 86+, Edge
          86+) ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
        </div>

        <!-- Input Selection -->
        <div class="form-section">
          <label>üìÇ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞</label>
          <div class="btn-group">
            <button class="btn btn-primary" id="selectFolderBtn">
              üìÅ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå
            </button>
          </div>
          <div class="file-info" id="inputInfo">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡∏û‡∏∏‡∏ï</div>
        </div>

        <!-- Advanced Settings Accordion -->
        <div class="accordion">
          <div class="accordion-header" id="settingsToggle">
            ‚öôÔ∏è ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á
            <span class="accordion-arrow">‚ñº</span>
          </div>
          <div class="accordion-content" id="settingsContent">
            <!-- Settings Grid -->
            <div class="settings-grid">
              <div class="form-section">
                <label>üìä Batch Size (‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏û‡∏•‡∏á‡∏ï‡πà‡∏≠‡∏ä‡∏∏‡∏î)</label>
                <input
                  type="number"
                  id="batchSize"
                  value="100"
                  min="10"
                  max="1000"
                />
              </div>

              <div class="form-section">
                <label>üíæ ZIP Size Limit (MB)</label>
                <input
                  type="number"
                  id="zipSizeLimit"
                  value="300"
                  min="50"
                  max="5000"
                />
              </div>

              <div class="form-section">
                <label>‚öôÔ∏è CPU Throttle (ms)</label>
                <input
                  type="number"
                  id="cpuThrottle"
                  value="0"
                  min="0"
                  max="1000"
                  step="1"
                />
              </div>
            </div>

            <!-- Checkboxes -->
            <div class="checkbox-group">
              <input type="checkbox" id="performanceMode" checked />
              <label for="performanceMode"
                >‚ö° Performance Mode (‡πÉ‡∏ä‡πâ CPU ‡∏™‡∏π‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß)</label
              >
            </div>

            <div class="checkbox-group">
              <input type="checkbox" id="createZips" checked />
              <label for="createZips"
                >üì¶ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå ZIP ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏û‡∏•‡∏á (karaoke_*.zip)</label
              >
            </div>

            <div class="checkbox-group">
              <input type="checkbox" id="createIndexZip" checked />
              <label for="createIndexZip">üîç ‡∏™‡∏£‡πâ‡∏≤‡∏á index.zip ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤</label>
            </div>
          </div>
        </div>

        <!-- Action Buttons -->
        <div class="btn-group" style="margin-top: 20px">
          <button class="btn btn-success" id="startBtn">
            ‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
          </button>
          <button class="btn btn-danger" id="stopBtn" disabled>
            ‚èπÔ∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
          </button>
        </div>

        <!-- Progress Section -->
        <div class="progress-section">
          <div class="status" id="statusText">‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏á‡∏≤‡∏ô</div>
          <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%">
              0%
            </div>
          </div>
          <div class="log-box" id="logBox"></div>
        </div>
      </div>

      <!-- About Section (Accordion for compactness) -->
      <div class="accordion">
        <div class="accordion-header" id="aboutToggle">
          ‚ÑπÔ∏è ‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡πÄ‡∏£‡∏≤
          <span class="accordion-arrow">‚ñº</span>
        </div>
        <div class="accordion-content" id="aboutContent">
          <p style="line-height: 1.6; color: var(--gray); font-size: 0.9rem">
            <strong style="color: var(--dark)">Next Karaoke</strong>
            ‡∏ñ‡∏∑‡∏≠‡∏Å‡∏≥‡πÄ‡∏ô‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏Ñ‡∏ô‡πÄ‡∏•‡πá‡∏Å‡πÜ ‡∏ó‡∏µ‡πà‡∏´‡∏•‡∏á‡πÉ‡∏´‡∏•‡πÉ‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏û‡∏•‡∏á‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î
            ‡πÄ‡∏£‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏à‡∏≤‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ô‡∏∏‡∏Å‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡πâ‡∏≠‡∏á‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡∏Å‡∏±‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡πÅ‡∏•‡∏∞‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏£‡∏±‡∏ß
            ‡πÅ‡∏ï‡πà‡∏Å‡πá‡∏°‡∏±‡∏Å‡∏à‡∏∞‡πÄ‡∏à‡∏≠‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÉ‡∏´‡∏ç‡πà‡∏Ñ‡∏∑‡∏≠‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏û‡∏•‡∏á‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡πÄ‡∏Å‡πà‡∏≤‡πÜ ‡πÇ‡∏î‡∏¢‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÑ‡∏ü‡∏•‡πå .EMK
            ‡∏ó‡∏µ‡πà‡πÄ‡∏Ñ‡∏¢‡πÇ‡∏î‡πà‡∏á‡∏î‡∏±‡∏á‡πÉ‡∏ô‡∏≠‡∏î‡∏µ‡∏ï ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏±‡∏ö‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏™‡∏°‡∏±‡∏¢‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏î‡πâ
            ‡πÄ‡∏£‡∏≤‡∏à‡∏∂‡∏á‡πÄ‡∏´‡πá‡∏ô‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡πâ‡∏≤‡∏ô‡πÄ‡∏ó‡∏Ñ‡πÇ‡∏ô‡πÇ‡∏•‡∏¢‡∏µ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏ô‡∏µ‡πâ‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö‡∏ä‡∏∏‡∏°‡∏ä‡∏ô‡∏Ñ‡∏ô‡∏£‡∏±‡∏Å‡∏Ñ‡∏≤‡∏£‡∏≤‡πÇ‡∏≠‡πÄ‡∏Å‡∏∞‡πÉ‡∏ô‡πÑ‡∏ó‡∏¢
          </p>
          <p
            style="
              line-height: 1.6;
              color: var(--gray);
              margin-top: 10px;
              font-size: 0.9rem;
            "
          >
            ‡πÄ‡∏£‡∏≤‡∏ï‡∏±‡πâ‡∏á‡πÉ‡∏à‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
            ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÉ‡∏´‡πâ‡∏¢‡∏∏‡πà‡∏á‡∏¢‡∏≤‡∏Å ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å‡∏ó‡∏∏‡∏Å‡∏ó‡∏µ‡πà ‡∏ó‡∏∏‡∏Å‡πÄ‡∏ß‡∏•‡∏≤
            ‡πÅ‡∏•‡∏∞‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏Ñ‡∏∑‡∏≠
            <strong style="color: var(--success)">"‡∏ü‡∏£‡∏µ"</strong>
            ‡πÄ‡∏£‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏ß‡πà‡∏≤‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡∏Ñ‡∏ß‡∏£‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ö‡∏±‡∏ô‡πÄ‡∏ó‡∏¥‡∏á‡πÅ‡∏•‡∏∞‡πÑ‡∏î‡πâ‡∏£‡∏∑‡πâ‡∏≠‡∏ü‡∏∑‡πâ‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏£‡∏á‡∏à‡∏≥‡∏î‡∏µ‡πÜ
            ‡∏ú‡πà‡∏≤‡∏ô‡∏ö‡∏ó‡πÄ‡∏û‡∏•‡∏á‡πÄ‡∏Å‡πà‡∏≤‡πÜ ‡∏ó‡∏µ‡πà‡∏û‡∏ß‡∏Å‡πÄ‡∏Ç‡∏≤‡∏£‡∏±‡∏Å‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÉ‡∏î‡πÜ
            ‡πÇ‡∏õ‡∏£‡∏î‡πÉ‡∏ä‡πâ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏™‡πà‡∏ß‡∏ô‡∏ö‡∏∏‡∏Ñ‡∏Ñ‡∏•‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏Å‡∏é‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
          </p>
        </div>
      </div>

      <!-- FAQ Section (Accordion for compactness) -->
      <div class="accordion">
        <div class="accordion-header" id="faqToggle">
          ‚ÑπÔ∏è ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏û‡∏ö‡∏ö‡πà‡∏≠‡∏¢ (FAQ)
          <span class="accordion-arrow">‚ñº</span>
        </div>
        <div class="accordion-content" id="faqContent">
          <dl style="font-size: 0.9rem; color: var(--gray); line-height: 1.6">
            <dt>Q: Karaoke Processor ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÉ‡∏î‡∏ö‡πâ‡∏≤‡∏á?</dt>
            <dd>
              A: ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡πÄ‡∏ä‡πà‡∏ô Chrome, Edge, Firefox ‡πÅ‡∏•‡∏∞
              Safari (‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î)
            </dd>

            <dt>Q: ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏≠‡∏ü‡πÑ‡∏•‡∏ô‡πå‡πÑ‡∏î‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?</dt>
            <dd>
              A: ‡πÑ‡∏î‡πâ ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î‡∏≠‡∏≠‡∏ô‡πÑ‡∏•‡∏ô‡πå ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡πÄ‡∏Å‡πá‡∏ö cache
              ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏≠‡∏ü‡πÑ‡∏•‡∏ô‡πå‡πÑ‡∏î‡πâ‡∏ö‡∏≤‡∏á‡∏™‡πà‡∏ß‡∏ô
            </dd>

            <dt>Q: ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?</dt>
            <dd>A: Karaoke Processor (Web) ‡πÄ‡∏õ‡πá‡∏ô‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ü‡∏£‡∏µ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ</dd>

            <dt>Q: ‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ‡πÉ‡∏ô‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?</dt>
            <dd>
              A: ‡πÑ‡∏°‡πà ‡∏ó‡∏∏‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÉ‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
            </dd>

            <dt>Q: ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏∞‡πÄ‡∏°‡∏¥‡∏î‡∏•‡∏¥‡∏Ç‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?</dt>
            <dd>
              A: ‡πÑ‡∏°‡πà
              ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ö‡∏∏‡∏Ñ‡∏Ñ‡∏•‡πÅ‡∏•‡∏∞‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏Å‡∏é‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
              ‡πÄ‡∏£‡∏≤‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏≤‡∏£‡∏û‡∏•‡∏¥‡∏Ç‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏Ñ‡∏£‡πà‡∏á‡∏Ñ‡∏£‡∏±‡∏î
            </dd>
          </dl>
        </div>
      </div>

      <!-- Footer -->
      <div class="footer">
        <p>Made with ‚ù§Ô∏è by Next Karaoke Team</p>
        <p style="margin-top: 8px; opacity: 0.8">
          ¬© 2025 Next Karaoke. All rights reserved. |
          <a href="#">‡∏ô‡πÇ‡∏¢‡∏ö‡∏≤‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏±‡∏ß</a>
        </p>
      </div>
    </div>

    <script>
      let rootDirHandle = null;
      let isProcessing = false;
      let shouldStop = false;
      let worker = null;
      let db = null;

      const DB_NAME = "KaraokeProcessorDB";
      const DB_VERSION = 1;
      const STORE_RECORDS = "records";
      const STORE_BATCHES = "batches";

      const elements = {
        selectFolderBtn: document.getElementById("selectFolderBtn"),
        inputInfo: document.getElementById("inputInfo"),
        startBtn: document.getElementById("startBtn"),
        stopBtn: document.getElementById("stopBtn"),
        statusText: document.getElementById("statusText"),
        progressFill: document.getElementById("progressFill"),
        logBox: document.getElementById("logBox"),
        batchSize: document.getElementById("batchSize"),
        zipSizeLimit: document.getElementById("zipSizeLimit"),
        cpuThrottle: document.getElementById("cpuThrottle"),
        createZips: document.getElementById("createZips"),
        createIndexZip: document.getElementById("createIndexZip"),
        performanceMode: document.getElementById("performanceMode"),
      };

      // Accordion logic
      const accordions = [
        { toggle: "settingsToggle", content: "settingsContent", arrow: true },
        { toggle: "aboutToggle", content: "aboutContent", arrow: true },
        { toggle: "faqToggle", content: "faqContent", arrow: true },
      ];

      accordions.forEach((acc) => {
        const toggle = document.getElementById(acc.toggle);
        const content = document.getElementById(acc.content);
        const arrow = toggle.querySelector(".accordion-arrow");

        toggle.addEventListener("click", () => {
          content.classList.toggle("open");
          if (arrow) arrow.classList.toggle("open");
        });
      });

      function log(message, type = "info") {
        const timestamp = new Date().toLocaleTimeString("th-TH");
        const logEntry = document.createElement("div");
        logEntry.className = `log-entry log-${type}`;

        const timeSpan = document.createElement("span");
        timeSpan.className = "log-timestamp";
        timeSpan.textContent = `[${timestamp}]`;

        const messageSpan = document.createElement("span");
        messageSpan.className = "log-message";
        messageSpan.textContent = message;

        logEntry.appendChild(timeSpan);
        logEntry.appendChild(messageSpan);

        elements.logBox.appendChild(logEntry);
        elements.logBox.scrollTop = elements.logBox.scrollHeight;

        while (elements.logBox.children.length > 1000) {
          elements.logBox.removeChild(elements.logBox.firstChild);
        }
      }

      function updateProgress(percent) {
        const rounded = Math.round(percent);
        elements.progressFill.style.width = `${rounded}%`;
        elements.progressFill.textContent = `${rounded}%`;
      }

      function updateStatus(text) {
        elements.statusText.textContent = text;
      }

      async function initDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, DB_VERSION);
          request.onerror = (event) =>
            reject("IndexedDB error: " + event.target.error);
          request.onsuccess = (event) => {
            db = event.target.result;
            resolve(db);
          };
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_RECORDS)) {
              db.createObjectStore(STORE_RECORDS, { keyPath: "_id" });
            }
            if (!db.objectStoreNames.contains(STORE_BATCHES)) {
              db.createObjectStore(STORE_BATCHES, { keyPath: "_batchId" });
            }
          };
        });
      }

      async function clearDBStore(storeName) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([storeName], "readwrite");
          const store = transaction.objectStore(storeName);
          const request = store.clear();
          request.onsuccess = resolve;
          request.onerror = (event) =>
            reject("Clear error: " + event.target.error);
        });
      }

      async function storeRecord(record, id) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_RECORDS], "readwrite");
          const store = transaction.objectStore(STORE_RECORDS);
          record._id = id;
          const request = store.put(record);
          request.onsuccess = resolve;
          request.onerror = (event) =>
            reject("Store error: " + event.target.error);
        });
      }

      async function getRecord(id) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_RECORDS]);
          const store = transaction.objectStore(STORE_RECORDS);
          const request = store.get(id);
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) =>
            reject("Get error: " + event.target.error);
        });
      }

      async function getRecordsCount() {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_RECORDS]);
          const store = transaction.objectStore(STORE_RECORDS);
          const request = store.count();
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) =>
            reject("Count error: " + event.target.error);
        });
      }

      async function storeBatch(batchId, batchData) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_BATCHES], "readwrite");
          const store = transaction.objectStore(STORE_BATCHES);
          const data = { _batchId: batchId, data: batchData };
          const request = store.put(data);
          request.onsuccess = resolve;
          request.onerror = (event) =>
            reject("Store batch error: " + event.target.error);
        });
      }

      async function getBatch(batchId) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_BATCHES]);
          const store = transaction.objectStore(STORE_BATCHES);
          const request = store.get(batchId);
          request.onsuccess = (event) => resolve(event.target.result?.data);
          request.onerror = (event) =>
            reject("Get batch error: " + event.target.error);
        });
      }

      async function getAllBatchKeys() {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_BATCHES]);
          const store = transaction.objectStore(STORE_BATCHES);
          const request = store.getAllKeys();
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) =>
            reject("Get keys error: " + event.target.error);
        });
      }

      const workerCode = () => {
        self.importScripts(
          "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"
        );

        function parseDBFHeader(buffer) {
          try {
            const view = new DataView(buffer);
            const recordCount = view.getUint32(4, true);
            const headerLength = view.getUint16(8, true);
            const recordLength = view.getUint16(10, true);

            const fieldCount = Math.floor((headerLength - 32 - 1) / 32);
            const fields = [];
            let offset = 32;

            for (let i = 0; i < fieldCount; i++) {
              const nameBytes = new Uint8Array(
                buffer.slice(offset, offset + 11)
              );
              const name = new TextDecoder("ascii")
                .decode(nameBytes)
                .replace(/\0/g, "")
                .trim();
              const type = String.fromCharCode(
                new Uint8Array(buffer.slice(offset + 11, offset + 12))[0]
              );
              const length = new Uint8Array(
                buffer.slice(offset + 16, offset + 17)
              )[0];
              fields.push({ name, type, length });
              offset += 32;
            }

            return { recordCount, headerLength, recordLength, fields };
          } catch (error) {
            throw new Error(`DBF Header Parsing Error: ${error.message}`);
          }
        }

        function tryDecode(bytes) {
          const encodings = ["windows-874", "utf-8"];
          for (const encoding of encodings) {
            try {
              return new TextDecoder(encoding).decode(bytes).trim();
            } catch (e) {
              continue;
            }
          }
          return "";
        }

        function parseDBFRecords(buffer, header) {
          try {
            const records = [];
            const dataStart = header.headerLength;
            const uint8Array = new Uint8Array(buffer);

            for (let i = 0; i < header.recordCount; i++) {
              const recordOffset = dataStart + i * header.recordLength;
              if (recordOffset + header.recordLength > buffer.byteLength) break;
              if (uint8Array[recordOffset] === 0x2a) continue;

              const record = {};
              let fieldOffset = recordOffset + 1;

              for (const field of header.fields) {
                const fieldBytes = uint8Array.slice(
                  fieldOffset,
                  fieldOffset + field.length
                );
                record[field.name] = tryDecode(fieldBytes);
                fieldOffset += field.length;
              }

              records.push(record);
            }

            return records;
          } catch (error) {
            throw new Error(`DBF Records Parsing Error: ${error.message}`);
          }
        }

        async function createMIDIZip(midi, lyr, cur, performanceMode) {
          try {
            const zip = new JSZip();
            zip.file("song.mid", midi);
            zip.file("song.lyr", lyr);
            zip.file("song.cur", cur);
            return await zip.generateAsync({
              type: "uint8array",
              compression: performanceMode ? "DEFLATE" : "DEFLATE",
              compressionOptions: performanceMode ? { level: 1 } : { level: 6 },
            });
          } catch (error) {
            throw new Error(`MIDI ZIP Creation Error: ${error.message}`);
          }
        }

        async function buildSearchIndex(records) {
          try {
            const wordMap = {};
            const chunks = {};
            let chunkId = 0;
            let currentChunk = {};
            let currentChunkSize = 0;
            const MAX_CHUNK_SIZE = 5 * 1024 * 1024;

            function extractWords(text) {
              return (text.match(/[a-zA-Z\d\u0e00-\u0e7f]+/g) || [])
                .map((w) => w.toLowerCase())
                .filter((w) => w.length > 1);
            }

            for (const record of records) {
              if (
                record._originalIndex === undefined ||
                record._superIndex === undefined
              )
                continue;

              const preview = {
                t: record.TITLE || "",
                a: record.ARTIST || "",
                i: record._originalIndex,
                s: record._superIndex,
              };

              const text = `${record.TITLE} ${record.ARTIST}`;
              const words = extractWords(text);

              for (const word of words) {
                if (!wordMap[word]) wordMap[word] = [];
                wordMap[word].push(preview);
              }
            }

            const sortedWords = Object.keys(wordMap).sort();
            const wordToChunk = {};

            for (const word of sortedWords) {
              const entrySize = JSON.stringify(wordMap[word]).length;

              if (
                currentChunkSize + entrySize > MAX_CHUNK_SIZE &&
                Object.keys(currentChunk).length > 0
              ) {
                chunks[chunkId] = currentChunk;
                chunkId++;
                currentChunk = {};
                currentChunkSize = 0;
              }

              currentChunk[word] = wordMap[word];
              wordToChunk[word] = chunkId;
              currentChunkSize += entrySize;
            }

            if (Object.keys(currentChunk).length > 0) {
              chunks[chunkId] = currentChunk;
            }

            const masterIndex = {
              totalRecords: records.length,
              words: sortedWords,
              wordToChunkMap: wordToChunk,
              buildTime: Date.now(),
              lastBuilt: new Date().toISOString(),
            };

            return { masterIndex, chunks };
          } catch (error) {
            throw new Error(`Search Index Building Error: ${error.message}`);
          }
        }

        self.onmessage = async (e) => {
          const { action, data } = e.data;
          try {
            if (action === "parseDBF") {
              const header = parseDBFHeader(data.buffer);
              const records = parseDBFRecords(data.buffer, header);
              self.postMessage({ action: "parseDBFResult", header, records });
            } else if (action === "createMIDIZip") {
              const zipData = await createMIDIZip(
                data.midi,
                data.lyr,
                data.cur,
                data.performanceMode
              );
              self.postMessage({ action: "createMIDIZipResult", zipData });
            } else if (action === "buildSearchIndex") {
              const indexData = await buildSearchIndex(data.records);
              self.postMessage({ action: "buildSearchIndexResult", indexData });
            }
          } catch (error) {
            self.postMessage({ action: "error", message: error.message });
          }
        };
      };

      const blob = new Blob([`(${workerCode.toString()})()`], {
        type: "application/javascript",
      });
      const workerURL = URL.createObjectURL(blob);
      worker = new Worker(workerURL);

      worker.onmessage = (e) => {
        const { action, message, header, records, zipData, indexData } = e.data;
        if (action === "parseDBFResult") {
          workerParseDBFResult(header, records);
        } else if (action === "createMIDIZipResult") {
          workerCreateMIDIZipResult(zipData);
        } else if (action === "buildSearchIndexResult") {
          workerBuildSearchIndexResult(indexData);
        } else if (action === "error") {
          log(`‚ùå Worker Error: ${message}`, "error");
          updateStatus("‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô Worker");
          isProcessing = false;
          elements.startBtn.disabled = false;
          elements.stopBtn.disabled = true;
        }
      };

      async function getFileByPath(pathParts) {
        const fullPath = pathParts.join("/");
        try {
          if (rootDirHandle) {
            let currentHandle = rootDirHandle;
            for (let i = 0; i < pathParts.length - 1; i++) {
              currentHandle = await currentHandle.getDirectoryHandle(
                pathParts[i],
                {
                  create: false,
                }
              );
            }
            const fileName = pathParts[pathParts.length - 1];
            const fileHandle = await currentHandle.getFileHandle(fileName);
            const file = await fileHandle.getFile();
            return { arrayBuffer: () => file.arrayBuffer() };
          }
          return null;
        } catch (e) {
          log(`‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå ${fullPath}: ${e.message}`, "warning");
          return null;
        }
      }

      async function getSongFiles(track) {
        if (!track.CODE || !track.TYPE || !track.SUB_TYPE) {
          log(`‚ö†Ô∏è Track ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö: ${JSON.stringify(track)}`, "warning");
          return null;
        }

        const code = track.CODE;
        const folder = code[0];
        const primaryPath = ["Songs", track.TYPE, track.SUB_TYPE];

        try {
          if (track.SUB_TYPE === "EMK") {
            let emkFile = await getFileByPath([
              ...primaryPath,
              folder,
              `${code}.emk`,
            ]);
            if (!emkFile) {
              emkFile = await getFileByPath([...primaryPath, `${code}.emk`]);
            }
            if (emkFile) {
              return { emk: await emkFile.arrayBuffer() };
            }
          } else if (track.SUB_TYPE === "NCN") {
            const [midiFile, lyrFile, curFile] = await Promise.all([
              getFileByPath([...primaryPath, "Song", folder, `${code}.mid`]) ||
                getFileByPath([...primaryPath, "Song", `${code}.mid`]),
              getFileByPath([
                ...primaryPath,
                "Lyrics",
                folder,
                `${code}.lyr`,
              ]) || getFileByPath([...primaryPath, "Lyrics", `${code}.lyr`]),
              getFileByPath([
                ...primaryPath,
                "Cursor",
                folder,
                `${code}.cur`,
              ]) || getFileByPath([...primaryPath, "Cursor", `${code}.cur`]),
            ]);

            if (midiFile && lyrFile && curFile) {
              const [midi, lyr, cur] = await Promise.all([
                midiFile.arrayBuffer(),
                lyrFile.arrayBuffer(),
                curFile.arrayBuffer(),
              ]);
              return { midi, lyr, cur };
            }
          }
          return null;
        } catch (e) {
          log(
            `‚ö†Ô∏è Error fetching song files for ${code}: ${e.message}`,
            "warning"
          );
          return null;
        }
      }

      let workerParseDBFResultResolve = null;
      let workerCreateMIDIZipResultResolve = null;
      let workerBuildSearchIndexResultResolve = null;

      function workerParseDBFResult(header, records) {
        if (workerParseDBFResultResolve) {
          workerParseDBFResultResolve({ header, records });
          workerParseDBFResultResolve = null;
        }
      }

      function workerCreateMIDIZipResult(zipData) {
        if (workerCreateMIDIZipResultResolve) {
          workerCreateMIDIZipResultResolve(zipData);
          workerCreateMIDIZipResultResolve = null;
        }
      }

      function workerBuildSearchIndexResult(indexData) {
        if (workerBuildSearchIndexResultResolve) {
          workerBuildSearchIndexResultResolve(indexData);
          workerBuildSearchIndexResultResolve = null;
        }
      }

      async function parseDBF(buffer) {
        return new Promise((resolve, reject) => {
          workerParseDBFResultResolve = resolve;
          worker.postMessage({ action: "parseDBF", data: { buffer } });
          setTimeout(() => reject(new Error("DBF parsing timeout")), 30000);
        });
      }

      async function createMIDIZip(midi, lyr, cur, performanceMode) {
        return new Promise((resolve, reject) => {
          workerCreateMIDIZipResultResolve = resolve;
          worker.postMessage({
            action: "createMIDIZip",
            data: { midi, lyr, cur, performanceMode },
          });
          setTimeout(
            () => reject(new Error("MIDI ZIP creation timeout")),
            10000
          );
        });
      }

      async function buildSearchIndex(records) {
        return new Promise((resolve, reject) => {
          workerBuildSearchIndexResultResolve = resolve;
          worker.postMessage({ action: "buildSearchIndex", data: { records } });
          setTimeout(
            () => reject(new Error("Search index building timeout")),
            60000
          );
        });
      }

      const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

      function downloadFile(blob, filename) {
        try {
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          setTimeout(() => URL.revokeObjectURL(url), 100);
        } catch (e) {
          log(`‚ùå Error downloading file ${filename}: ${e.message}`, "error");
        }
      }

      async function processKaraoke() {
        shouldStop = false;
        isProcessing = true;

        try {
          await initDB();
          await clearDBStore(STORE_RECORDS);
          await clearDBStore(STORE_BATCHES);

          if (!rootDirHandle) {
            throw new Error("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏Å‡πà‡∏≠‡∏ô");
          }

          updateStatus("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå SONG.DBF...");
          log("üìñ ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå Data/SONG.DBF", "info");

          const dbfFile = await getFileByPath(["Data", "SONG.DBF"]);
          if (!dbfFile) {
            throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå Data/SONG.DBF");
          }

          const dbfBuffer = await dbfFile.arrayBuffer();
          updateProgress(5);

          log("üîç ‡∏Å‡∏≥‡∏•‡∏±‡∏á parse DBF header...", "info");
          let { header, records } = await parseDBF(dbfBuffer);
          log(
            `‚úÖ ‡∏û‡∏ö ${header.recordCount} records, ${header.fields.length} fields`,
            "info"
          );

          updateProgress(10);
          log(`‚úÖ Parse ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ${records.length} ‡πÄ‡∏û‡∏•‡∏á`, "info");

          log("üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å records ‡∏•‡∏á IndexedDB...", "info");
          for (let i = 0; i < records.length; i++) {
            await storeRecord(records[i], i);
          }
          records = null;

          updateProgress(15);

          if (shouldStop) throw new Error("‡∏´‡∏¢‡∏∏‡∏î‡πÇ‡∏î‡∏¢‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ");

          const config = {
            batchSize: parseInt(elements.batchSize.value),
            zipSizeLimit: parseInt(elements.zipSizeLimit.value) * 1024 * 1024,
            cpuThrottle: parseInt(elements.cpuThrottle.value),
            createZips: elements.createZips.checked,
            createIndexZip: elements.createIndexZip.checked,
            performanceMode: elements.performanceMode.checked,
          };

          log(
            `‚öôÔ∏è Config: Batch=${config.batchSize}, Limit=${(
              config.zipSizeLimit /
              1024 /
              1024
            ).toFixed(0)}MB, Throttle=${config.cpuThrottle}ms, Performance=${
              config.performanceMode
            }`,
            "info"
          );
          updateStatus("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏û‡∏•‡∏á...");

          const totalRecords = await getRecordsCount();
          let processedCount = 0;
          let currentBatch = [];
          let currentBatchZip = config.createZips ? new JSZip() : null;
          let currentBatchSize = 0;
          let batchIndex = 0;
          const parallelBatchSize = config.performanceMode ? 50 : 20;
          const compressionLevel = config.performanceMode ? 1 : 3;

          for (let i = 0; i < totalRecords; i += parallelBatchSize) {
            if (shouldStop) throw new Error("‡∏´‡∏¢‡∏∏‡∏î‡πÇ‡∏î‡∏¢‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ");

            const end = Math.min(i + parallelBatchSize, totalRecords);
            const batchPromises = [];

            for (let j = i; j < end; j++) {
              batchPromises.push(
                (async () => {
                  const track = await getRecord(j);
                  if (!track) {
                    processedCount++; // ‡πÄ‡∏û‡∏¥‡πà‡∏° index ‡πÅ‡∏°‡πâ‡πÑ‡∏°‡πà‡∏°‡∏µ track
                    return null;
                  }

                  // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î index ‡∏Å‡πà‡∏≠‡∏ô‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô‡πÄ‡∏™‡∏°‡∏≠
                  const currentIndex = processedCount;
                  processedCount++;

                  try {
                    const files = await getSongFiles(track);
                    if (!files) {
                      // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå ‡πÅ‡∏ï‡πà index ‡∏ñ‡∏π‡∏Å‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß (‡∏Ç‡πâ‡∏≤‡∏° index ‡∏ô‡∏µ‡πâ)
                      return null;
                    }

                    let content = null;
                    let filename = "";

                    if (
                      track.SUB_TYPE === "NCN" &&
                      files.midi &&
                      files.lyr &&
                      files.cur
                    ) {
                      const zip = new JSZip();
                      zip.file("song.mid", files.midi);
                      zip.file("song.lyr", files.lyr);
                      zip.file("song.cur", files.cur);
                      content = await zip.generateAsync({
                        type: "uint8array",
                        compression: "DEFLATE",
                        compressionOptions: { level: compressionLevel },
                      });
                      filename = `${currentIndex}.zip`;
                    } else if (track.SUB_TYPE === "EMK" && files.emk) {
                      content = new Uint8Array(files.emk);
                      filename = `${currentIndex}.emk`;
                    }

                    // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å index ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
                    track._originalIndex = currentIndex;
                    track._superIndex = batchIndex;

                    await storeRecord(track, j);

                    return { trackId: j, content, filename };
                  } catch (e) {
                    // ‡πÄ‡∏Å‡∏¥‡∏î error ‡πÅ‡∏ï‡πà index ‡∏ñ‡∏π‡∏Å‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß
                    return null;
                  }
                })()
              );

            const results = await Promise.all(batchPromises);
            results.forEach((result) => {
              if (result && result.content) {
                currentBatch.push(result);

                if (config.createZips && currentBatchZip) {
                  currentBatchZip.file(result.filename, result.content);
                  currentBatchSize += result.content.length;
                }
              }
            });

            if (
              currentBatch.length >= config.batchSize ||
              (config.createZips && currentBatchSize >= config.zipSizeLimit)
            ) {
              if (config.createZips && currentBatchZip) {
                log(
                  `üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å batch ${batchIndex}: ${
                    currentBatch.length
                  } ‡πÄ‡∏û‡∏•‡∏á (${(currentBatchSize / 1024 / 1024).toFixed(2)}MB)`,
                  "info"
                );
                const batchData = await currentBatchZip.generateAsync({
                  type: "uint8array",
                  compression: config.performanceMode ? "DEFLATE" : "DEFLATE",
                  compressionOptions: config.performanceMode
                    ? { level: 1 }
                    : { level: 6 },
                });
                await storeBatch(batchIndex, batchData);
                currentBatchZip = null;
              }

              batchIndex++;
              currentBatch = [];
              currentBatchZip = config.createZips ? new JSZip() : null;
              currentBatchSize = 0;
            }

            const progress = 15 + Math.floor((end / totalRecords) * 70);
            updateProgress(progress);
            log(
              `‚è≥ ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•: ${processedCount}/${totalRecords} (${end} records)`,
              "info"
            );

            if (
              (i % 100 === 0 || end >= totalRecords) &&
              config.cpuThrottle > 0
            ) {
              await sleep(
                config.performanceMode
                  ? Math.min(config.cpuThrottle, 1)
                  : config.cpuThrottle
              );
            }
          }

          if (currentBatch.length > 0 && config.createZips && currentBatchZip) {
            log(
              `üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å batch ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ ${batchIndex}: ${currentBatch.length} ‡πÄ‡∏û‡∏•‡∏á`,
              "info"
            );
            const batchData = await currentBatchZip.generateAsync({
              type: "uint8array",
              compression: config.performanceMode ? "DEFLATE" : "DEFLATE",
              compressionOptions: config.performanceMode
                ? { level: 1 }
                : { level: 6 },
            });
            await storeBatch(batchIndex, batchData);
            currentBatchZip = null;
          }

          updateProgress(85);
          log(
            `‚úÖ ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à: ${processedCount} ‡πÄ‡∏û‡∏•‡∏á ‡∏à‡∏≤‡∏Å ${totalRecords} records`,
            "info"
          );

          if (config.createZips) {
            log("üì¶ ‡∏™‡∏£‡πâ‡∏≤‡∏á karaoke archives...", "info");
            updateStatus("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á karaoke_*.zip...");

            let archiveIndex = 0;
            let currentArchive = new JSZip();
            let currentArchiveSize = 0;

            const batchKeys = await getAllBatchKeys();
            for (const batchId of batchKeys.sort((a, b) => a - b)) {
              const batchData = await getBatch(batchId);

              if (
                currentArchiveSize + batchData.length > config.zipSizeLimit &&
                currentArchiveSize > 0
              ) {
                const archiveData = await currentArchive.generateAsync({
                  type: "blob",
                  compression: config.performanceMode ? "DEFLATE" : "DEFLATE",
                  compressionOptions: config.performanceMode
                    ? { level: 1 }
                    : { level: 6 },
                });
                downloadFile(archiveData, `karaoke_${archiveIndex}.zip`);
                log(
                  `‚úÖ ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î karaoke_${archiveIndex}.zip (${(
                    archiveData.size /
                    1024 /
                    1024
                  ).toFixed(2)}MB)`,
                  "info"
                );

                archiveIndex++;
                currentArchive = new JSZip();
                currentArchiveSize = 0;
              }

              currentArchive.file(`${batchId}.zip`, batchData);
              currentArchiveSize += batchData.length;
            }

            if (currentArchiveSize > 0) {
              const archiveData = await currentArchive.generateAsync({
                type: "blob",
                compression: "DEFLATE",
                compressionOptions: { level: config.performanceMode ? 1 : 6 },
              });
              downloadFile(archiveData, `karaoke_${archiveIndex}.zip`);
              log(
                `‚úÖ ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î karaoke_${archiveIndex}.zip (${(
                  archiveData.size /
                  1024 /
                  1024
                ).toFixed(2)}MB)`,
                "info"
              );
            }
          }
          updateProgress(95);

          if (config.createIndexZip) {
            log("üîç ‡∏™‡∏£‡πâ‡∏≤‡∏á search index...", "info");
            updateStatus("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á index.zip...");

            const recordsForIndex = [];
            const total = await getRecordsCount();
            const indexBatchSize = 500;
            for (let i = 0; i < total; i += indexBatchSize) {
              const end = Math.min(i + indexBatchSize, total);
              for (let j = i; j < end; j++) {
                const record = await getRecord(j);
                if (record) recordsForIndex.push(record);
              }
            }

            const { masterIndex, chunks } = await buildSearchIndex(
              recordsForIndex
            );

            const indexZip = new JSZip();
            indexZip.file("master.json", JSON.stringify(masterIndex));
            for (const chunkId in chunks) {
              indexZip.file(
                `chunk_${chunkId}.json`,
                JSON.stringify(chunks[chunkId])
              );
            }
            const indexZipData = await indexZip.generateAsync({ type: "blob" });
            downloadFile(indexZipData, "index.zip");
            log(
              `‚úÖ ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î index.zip (${(indexZipData.size / 1024).toFixed(
                2
              )}KB)`,
              "info"
            );
          }

          updateProgress(100);
          updateStatus("üéâ ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô!");
          log("üéâ ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå!", "info");
        } catch (error) {
          if (error.message === "‡∏´‡∏¢‡∏∏‡∏î‡πÇ‡∏î‡∏¢‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ") {
            log("‚èπÔ∏è ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏´‡∏¢‡∏∏‡∏î‡∏•‡∏á‡∏ï‡∏≤‡∏°‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á", "warning");
            updateStatus("‚èπÔ∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß");
          } else {
            log(`‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏£‡πâ‡∏≤‡∏¢‡πÅ‡∏£‡∏á: ${error.message}`, "error");
            updateStatus("‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î!");
          }
        } finally {
          isProcessing = false;
          elements.startBtn.disabled = false;
          elements.stopBtn.disabled = true;

          await clearDBStore(STORE_RECORDS);
          await clearDBStore(STORE_BATCHES);
        }
      }

      elements.selectFolderBtn.addEventListener("click", async () => {
        if ("showDirectoryPicker" in window) {
          try {
            const handle = await window.showDirectoryPicker();
            rootDirHandle = handle;
            elements.inputInfo.textContent = `üìÅ ‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå: ${handle.name}`;
            log(`üìÅ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå: ${handle.name}`, "info");
          } catch (err) {
            log("‚ö†Ô∏è ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå", "warning");
          }
        } else {
          alert("‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö File System Access API");
          log("‚ùå ‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö File System Access API", "error");
        }
      });

      elements.startBtn.addEventListener("click", () => {
        elements.logBox.innerHTML = "";
        updateProgress(0);
        elements.startBtn.disabled = true;
        elements.stopBtn.disabled = false;
        processKaraoke();
      });

      elements.stopBtn.addEventListener("click", () => {
        shouldStop = true;
        log("‚èπÔ∏è ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏´‡∏¢‡∏∏‡∏î...", "warning");
        updateStatus("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏´‡∏¢‡∏∏‡∏î...");
        elements.stopBtn.disabled = true;
      });
    </script>
  </body>
</html>
