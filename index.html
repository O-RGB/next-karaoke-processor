<!DOCTYPE html>
<html lang="th">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index, follow" />
    <meta
      name="description"
      content="เครื่องมือแปลงไฟล์คาราโอเกะฟรี รองรับ .EMK, .DBF ไม่ต้องติดตั้งโปรแกรม ใช้งานผ่านเว็บได้ทันที พร้อมข้อมูลเกี่ยวกับคาราโอเกะและวิธีใช้งาน"
    />
    <meta
      name="keywords"
      content="แปลงไฟล์คาราโอเกะ, EMK converter, DBF converter, karaoke converter ไทย, เครื่องมือคาราโอเกะฟรี, คาราโอเกะออนไลน์"
    />
    <title>Next Karaoke Processor - แปลงไฟล์คาราโอเกะฟรี</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      :root {
        --primary: #6366f1;
        --primary-dark: #4f46e5;
        --secondary: #8b5cf6;
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --dark: #1e293b;
        --light: #f8fafc;
        --gray: #64748b;
        --border: #e2e8f0;
      }
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
        color: var(--dark);
      }
      .container {
        max-width: 800px;
        margin: 0 auto;
      }
      .hero {
        text-align: center;
        color: white;
        margin-bottom: 30px;
        animation: fadeInDown 0.8s ease-out;
      }
      .hero h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }
      .hero .subtitle {
        font-size: 1.1rem;
        opacity: 0.9;
        margin-bottom: 15px;
      }
      .hero .features {
        display: flex;
        justify-content: center;
        gap: 20px;
        flex-wrap: wrap;
        margin-top: 15px;
      }
      .feature-badge {
        background: rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
        padding: 8px 16px;
        border-radius: 50px;
        font-size: 0.85rem;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .card {
        background: white;
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 15px 45px rgba(0, 0, 0, 0.25);
        margin-bottom: 15px;
        animation: fadeInUp 0.8s ease-out;
      }
      .card-header {
        border-bottom: 2px solid var(--border);
        padding-bottom: 15px;
        margin-bottom: 20px;
      }
      .card-header h2 {
        color: var(--primary);
        font-size: 1.5rem;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .alert {
        background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
        border-left: 4px solid var(--warning);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        line-height: 1.5;
        font-size: 0.9rem;
      }
      .alert strong {
        display: block;
        margin-bottom: 8px;
        color: #92400e;
      }
      .form-section {
        margin-bottom: 15px;
      }
      .form-section label {
        display: block;
        font-weight: 600;
        margin-bottom: 8px;
        color: var(--dark);
        font-size: 0.9rem;
      }
      .btn-group {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 6px;
        flex: 1;
        justify-content: center;
        min-width: 120px;
      }
      .btn-primary {
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--secondary) 100%
        );
        color: white;
      }
      .btn-primary:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(99, 102, 241, 0.3);
      }
      .btn-success {
        background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
        color: white;
      }
      .btn-success:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(16, 185, 129, 0.3);
      }
      .btn-danger {
        background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
        color: white;
      }
      .btn-danger:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(239, 68, 68, 0.3);
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .file-info {
        background: var(--light);
        padding: 12px 16px;
        border-radius: 8px;
        margin-top: 10px;
        border: 2px dashed var(--border);
        text-align: center;
        color: var(--gray);
        font-weight: 500;
        font-size: 0.9rem;
      }
      .file-info.active {
        background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
        border-color: var(--primary);
        color: var(--primary-dark);
      }
      input[type="number"] {
        width: 100%;
        padding: 10px 14px;
        border: 2px solid var(--border);
        border-radius: 8px;
        font-size: 0.95rem;
        transition: all 0.3s ease;
      }
      input[type="number"]:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
      }
      .checkbox-group {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 12px;
        background: var(--light);
        border-radius: 8px;
        margin-bottom: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.9rem;
      }
      .checkbox-group:hover {
        background: #e0e7ff;
      }
      .checkbox-group input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--primary);
      }
      .checkbox-group label {
        cursor: pointer;
        margin: 0;
        flex: 1;
      }
      .progress-section {
        margin-top: 20px;
      }
      .status {
        text-align: center;
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: 15px;
        color: var(--primary);
        padding: 12px;
        background: var(--light);
        border-radius: 8px;
      }
      .progress-bar {
        width: 100%;
        height: 30px;
        background: var(--light);
        border-radius: 15px;
        overflow: hidden;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 15px;
      }
      .progress-fill {
        height: 100%;
        background: linear-gradient(
          90deg,
          var(--primary) 0%,
          var(--secondary) 100%
        );
        transition: width 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 600;
        font-size: 0.85rem;
      }
      .log-box {
        background: #1e293b;
        border-radius: 8px;
        padding: 10px;
        min-height: 250px;
        max-height: 250px;
        overflow-y: auto;
        font-family: "Courier New", monospace;
        font-size: 0.8rem;
        box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.5);
      }
      .log-entry {
        padding: 3px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      .log-entry:last-child {
        border-bottom: none;
      }
      .log-timestamp {
        color: #94a3b8;
        margin-right: 8px;
      }
      .log-message {
        color: #e2e8f0;
      }
      .log-info .log-message {
        color: #60a5fa;
      }
      .log-warning .log-message {
        color: #fbbf24;
      }
      .log-error .log-message {
        color: #f87171;
      }
      .settings-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 15px;
      }
      .footer {
        text-align: center;
        color: white;
        margin-top: 30px;
        padding: 15px;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 10px;
        font-size: 0.85rem;
      }
      .footer a {
        color: white;
        text-decoration: none;
        font-weight: 600;
      }
      .footer a:hover {
        text-decoration: underline;
      }
      .accordion {
        margin-bottom: 15px;
      }
      .accordion-header {
        background: var(--light);
        padding: 12px 15px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        color: var(--primary);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .accordion-content {
        max-height: 1000px; /* เปิดโดย default */
        overflow: hidden;
        transition: max-height 0.3s ease;
        padding: 15px;
        background: #fff;
        border-radius: 10px;
        margin-top: 5px;
        opacity: 1;
      }
      .accordion-content.closed {
        max-height: 0;
        padding: 0px;
        margin-top: 0px;
        opacity: 0;
      }
      .accordion-arrow {
        transition: transform 0.3s ease;
      }
      .accordion-arrow.closed {
        transform: rotate(180deg);
      }
      .content-section {
        background: white;
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 15px;
        box-shadow: 0 15px 45px rgba(0, 0, 0, 0.25);
        animation: fadeInUp 0.8s ease-out;
      }
      .content-section h2 {
        color: var(--primary);
        font-size: 1.5rem;
        margin-bottom: 15px;
      }
      .content-section p {
        line-height: 1.6;
        color: var(--gray);
        font-size: 0.9rem;
        margin-bottom: 10px;
      }
      @keyframes fadeInDown {
        from {
          opacity: 0;
          transform: translateY(-20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      @media (max-width: 768px) {
        .hero h1 {
          font-size: 1.8rem;
        }
        .hero .subtitle {
          font-size: 0.95rem;
        }
        .hero .features {
          gap: 10px;
        }
        .feature-badge {
          font-size: 0.75rem;
          padding: 6px 12px;
        }
        .card {
          padding: 15px;
        }
        .btn-group {
          flex-direction: column;
        }
        .btn {
          width: 100%;
        }
        .settings-grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Hero Section -->
      <div class="hero">
        <h1>🎤 Next Karaoke Processor</h1>
        <p class="subtitle">
          แปลงไฟล์คาราโอเกะฟรี ไม่ต้องติดตั้งโปรแกรม
          สำหรับการใช้งานส่วนบุคคลและไฟล์ที่ถูกต้องตามกฎหมายลิขสิทธิ์
        </p>
        <div class="features">
          <div class="feature-badge">✓ ฟรี 100%</div>
          <div class="feature-badge">✓ ปลอดภัย</div>
          <div class="feature-badge">✓ ใช้งานง่าย</div>
          <div class="feature-badge">✓ รองรับ EMK, DBF</div>
        </div>
      </div>
      <!-- New Content Section -->
      <div class="content-section">
        <h2>🎵 เกี่ยวกับคาราโอเกะและวิธีใช้งาน</h2>
        <p>
          คาราโอเกะเป็นกิจกรรมยอดนิยมในประเทศไทยที่นำความสนุกสนานและความทรงจำดีๆ
          ผ่านบทเพลง Next Karaoke Processor
          เป็นเครื่องมือที่ช่วยให้คุณแปลงไฟล์คาราโอเกะเก่าในรูปแบบ .EMK และ .DBF
          ให้สามารถใช้งานได้ในยุคสมัยใหม่ โดยไม่ต้องติดตั้งซอฟต์แวร์ใดๆ
          เพียงเลือกโฟลเดอร์ที่มีไฟล์คาราโอเกะ แล้วกดเริ่มประมวลผล คุณจะได้ไฟล์
          ZIP ที่พร้อมใช้งานทันที
        </p>
        <p>
          <strong>วิธีใช้งานง่ายๆ:</strong><br />
          1. คลิก "เลือกโฟลเดอร์" เพื่อเลือกโฟลเดอร์ที่มีไฟล์ SONG.DBF
          และเพลงคาราโอเกะ<br />
          2. ปรับการตั้งค่าขั้นสูง (ถ้าต้องการ) เช่น ขนาด batch หรือการสร้าง
          index<br />
          3. กด "เริ่มประมวลผล" และรอจนเสร็จ
          ไฟล์จะถูกบันทึกลงฐานข้อมูลในเครื่องคุณ<br />
          4. ดาวน์โหลดไฟล์จากส่วน "ไฟล์ที่พร้อมดาวน์โหลด" ได้เลย!
        </p>
        <p>
          เครื่องมือนี้เหมาะสำหรับผู้ที่ต้องการรื้อฟื้นความทรงจำเก่าๆ
          ผ่านเพลงคาราโอเกะ โดยเฉพาะไฟล์เก่าที่หาโปรแกรมเล่นยากในปัจจุบัน
          โปรดใช้สำหรับไฟล์ที่ถูกต้องตามลิขสิทธิ์เท่านั้น
        </p>
      </div>
      <!-- Main Card -->
      <div class="card">
        <div class="card-header">
          <h2>🚀 เริ่มต้นใช้งาน</h2>
        </div>
        <!-- Warning Alert -->
        <div class="alert">
          <strong>⚠️ ข้อกำหนดการใช้งาน:</strong>
          ต้องใช้เบราว์เซอร์ที่รองรับ File System Access API (Chrome 86+, Edge
          86+) เท่านั้น
        </div>
        <!-- Input Selection -->
        <div class="form-section">
          <label>📂 เลือกโฟลเดอร์คาราโอเกะ</label>
          <div class="btn-group">
            <button class="btn btn-primary" id="selectFolderBtn">
              📁 เลือกโฟลเดอร์
            </button>
          </div>
          <div class="file-info" id="inputInfo">ยังไม่ได้เลือกอินพุต</div>
        </div>
        <!-- Advanced Settings Accordion -->
        <div class="accordion">
          <div class="accordion-header" id="settingsToggle">
            ⚙️ การตั้งค่าขั้นสูง
            <span class="accordion-arrow">▼</span>
          </div>
          <div class="accordion-content closed" id="settingsContent">
            <!-- Settings Grid -->
            <div class="settings-grid">
              <div class="form-section">
                <label>📊 Batch Size (จำนวนเพลงต่อชุด)</label>
                <input
                  type="number"
                  id="batchSize"
                  value="100"
                  min="10"
                  max="1000"
                />
              </div>
              <div class="form-section">
                <label>💾 ZIP Size Limit (MB)</label>
                <input
                  type="number"
                  id="zipSizeLimit"
                  value="300"
                  min="50"
                  max="5000"
                />
              </div>
              <div class="form-section">
                <label>⚙️ CPU Throttle (ms)</label>
                <input
                  type="number"
                  id="cpuThrottle"
                  value="100"
                  min="0"
                  max="1000"
                  step="1"
                />
              </div>
            </div>
            <!-- Checkboxes -->
            <div class="checkbox-group">
              <input type="checkbox" id="performanceMode" checked />
              <label for="performanceMode"
                >⚡ Performance Mode (ใช้ CPU สูงเพื่อความเร็ว)</label
              >
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="createZips" checked />
              <label for="createZips"
                >📦 สร้างไฟล์ ZIP สำหรับเพลง (karaoke_*.zip)</label
              >
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="createIndexZip" checked />
              <label for="createIndexZip">🔍 สร้าง index.zip สำหรับค้นหา</label>
            </div>
          </div>
        </div>
        <!-- Action Buttons -->
        <div class="btn-group" style="margin-top: 20px">
          <button class="btn btn-success" id="startBtn">
            ▶️ เริ่มประมวลผล
          </button>
          <button class="btn btn-danger" id="stopBtn" disabled>
            ⏹️ หยุดการทำงาน
          </button>
        </div>
        <!-- Progress Section -->
        <div class="progress-section">
          <div class="status" id="statusText">พร้อมเริ่มงาน</div>
          <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%">
              0%
            </div>
          </div>
          <div class="log-box" id="logBox"></div>
        </div>
      </div>
      <!-- About Section (Accordion, เปิดโดย default) -->
      <div class="accordion">
        <div class="accordion-header" id="aboutToggle">
          ℹ️ เกี่ยวกับเรา
          <span class="accordion-arrow">▼</span>
        </div>
        <div class="accordion-content" id="aboutContent">
          <p style="line-height: 1.6; color: var(--gray); font-size: 0.9rem">
            <strong style="color: var(--dark)">Next Karaoke</strong>
            ถือกำเนิดขึ้นจากกลุ่มคนเล็กๆ ที่หลงใหลในเสียงเพลงและการเขียนโค้ด
            เราเริ่มต้นจากความสนุกในการร้องคาราโอเกะกับเพื่อนและครอบครัว
            แต่ก็มักจะเจอปัญหาใหญ่คือไฟล์เพลงคาราโอเกะเก่าๆ โดยเฉพาะไฟล์ .EMK
            ที่เคยโด่งดังในอดีต ไม่สามารถเปิดกับโปรแกรมสมัยใหม่ได้
            เราจึงเห็นโอกาสที่จะใช้ความสามารถด้านเทคโนโลยีของเราเพื่อแก้ปัญหานี้ให้กับชุมชนคนรักคาราโอเกะในไทย
          </p>
          <p
            style="
              line-height: 1.6;
              color: var(--gray);
              margin-top: 10px;
              font-size: 0.9rem;
            "
          >
            เราตั้งใจสร้างเครื่องมือที่ใช้งานง่ายที่สุด
            ไม่ต้องติดตั้งโปรแกรมให้ยุ่งยาก สามารถแปลงไฟล์ได้จากทุกที่ ทุกเวลา
            และที่สำคัญที่สุดคือ
            <strong style="color: var(--success)">"ฟรี"</strong>
            เราเชื่อว่าทุกคนควรมีสิทธิ์เข้าถึงความบันเทิงและได้รื้อฟื้นความทรงจำดีๆ
            ผ่านบทเพลงเก่าๆ ที่พวกเขารักโดยไม่มีข้อจำกัดใดๆ
            โปรดใช้บริการนี้สำหรับไฟล์ส่วนบุคคลที่ถูกต้องตามกฎหมายเท่านั้น
          </p>
        </div>
      </div>
      <!-- FAQ Section (ย้ายออกจาก accordion) -->
      <div class="content-section">
        <h2>ℹ️ คำถามที่พบบ่อย (FAQ)</h2>
        <dl style="font-size: 0.9rem; color: var(--gray); line-height: 1.6">
          <dt>
            <strong>ถาม: Karaoke Processor รองรับเบราว์เซอร์ใดบ้าง?</strong>
          </dt>
          <dd>
            ตอบ: รองรับเบราว์เซอร์หลักทั้งหมด เช่น Chrome, Edge, Firefox และ
            Safari (เวอร์ชันล่าสุด)
          </dd>
          <dt><strong>ถาม: สามารถใช้งานออฟไลน์ได้หรือไม่?</strong></dt>
          <dd>
            ตอบ: ได้ หากเปิดใช้งานครั้งแรกในโหมดออนไลน์ ระบบจะเก็บ cache
            เพื่อให้ทำงานออฟไลน์ได้บางส่วน
          </dd>
          <dt><strong>ถาม: มีค่าใช้จ่ายในการใช้งานหรือไม่?</strong></dt>
          <dd>ตอบ: Karaoke Processor (Web) เป็นบริการฟรีสำหรับผู้ใช้ทั่วไป</dd>
          <dt>
            <strong
              >ถาม: ไฟล์ที่อัปโหลดจะถูกเก็บไว้ในเซิร์ฟเวอร์หรือไม่?</strong
            >
          </dt>
          <dd>
            ตอบ: ไม่ ทุกไฟล์จะถูกประมวลผลในเครื่องของคุณผ่านเบราว์เซอร์โดยตรง
          </dd>
          <dt>
            <strong>ถาม: บริการนี้สนับสนุนการละเมิดลิขสิทธิ์หรือไม่?</strong>
          </dt>
          <dd>
            ตอบ: ไม่
            บริการนี้สำหรับการใช้งานส่วนบุคคลและไฟล์ที่ถูกต้องตามกฎหมายเท่านั้น
            เราสนับสนุนการเคารพลิขสิทธิ์อย่างเคร่งครัด
          </dd>
        </dl>
      </div>
      <!-- Footer -->
      <div class="footer">
        <p>Made with ❤️ by Next Karaoke Team</p>
        <p style="margin-top: 8px; opacity: 0.8">
          © 2025 Next Karaoke. All rights reserved. |
          <a href="#">นโยบายความเป็นส่วนตัว</a>
        </p>
      </div>
    </div>
    <script>
      let rootDirHandle = null;
      let isProcessing = false;
      let shouldStop = false;
      let worker = null;
      let db = null;
      const DB_NAME = "KaraokeProcessorDB";
      const DB_VERSION = 2;
      const STORE_RECORDS = "records";
      const STORE_BATCHES = "batches";
      const STORE_ARCHIVES = "archives";
      const elements = {
        selectFolderBtn: document.getElementById("selectFolderBtn"),
        inputInfo: document.getElementById("inputInfo"),
        startBtn: document.getElementById("startBtn"),
        stopBtn: document.getElementById("stopBtn"),
        statusText: document.getElementById("statusText"),
        progressFill: document.getElementById("progressFill"),
        logBox: document.getElementById("logBox"),
        batchSize: document.getElementById("batchSize"),
        zipSizeLimit: document.getElementById("zipSizeLimit"),
        cpuThrottle: document.getElementById("cpuThrottle"),
        createZips: document.getElementById("createZips"),
        createIndexZip: document.getElementById("createIndexZip"),
        performanceMode: document.getElementById("performanceMode"),
      };

      // Accordion logic
      const accordions = [
        { toggle: "settingsToggle", content: "settingsContent", arrow: true },
        { toggle: "aboutToggle", content: "aboutContent", arrow: true },
      ];
      accordions.forEach((acc) => {
        const toggle = document.getElementById(acc.toggle);
        const content = document.getElementById(acc.content);
        const arrow = toggle.querySelector(".accordion-arrow");
        toggle.addEventListener("click", () => {
          content.classList.toggle("closed");
          if (arrow) arrow.classList.toggle("closed");
        });
      });

      // โหลด AdSense หลังหน้าโหลดเสร็จ
      window.addEventListener("load", () => {
        const adScript = document.createElement("script");
        adScript.async = true;
        adScript.src =
          "https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1343885117561998";
        adScript.crossOrigin = "anonymous";
        document.head.appendChild(adScript);
        adScript.onload = () => {
          try {
            (adsbygoogle = window.adsbygoogle || []).push({});
          } catch (e) {
            console.error("AdSense load error:", e);
          }
        };
      });

      function log(message, type = "info") {
        const timestamp = new Date().toLocaleTimeString("th-TH");
        const logEntry = document.createElement("div");
        logEntry.className = `log-entry log-${type}`;
        const timeSpan = document.createElement("span");
        timeSpan.className = "log-timestamp";
        timeSpan.textContent = `[${timestamp}]`;
        const messageSpan = document.createElement("span");
        messageSpan.className = "log-message";
        messageSpan.textContent = message;
        logEntry.appendChild(timeSpan);
        logEntry.appendChild(messageSpan);
        elements.logBox.appendChild(logEntry);
        elements.logBox.scrollTop = elements.logBox.scrollHeight;
        while (elements.logBox.children.length > 1000) {
          elements.logBox.removeChild(elements.logBox.firstChild);
        }
      }

      function updateProgress(percent) {
        const rounded = Math.round(percent);
        elements.progressFill.style.width = `${rounded}%`;
        elements.progressFill.textContent = `${rounded}%`;
      }

      function updateStatus(text) {
        elements.statusText.textContent = text;
      }

      async function initDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, DB_VERSION);
          request.onerror = (event) =>
            reject("IndexedDB error: " + event.target.error);
          request.onsuccess = (event) => {
            db = event.target.result;
            resolve(db);
          };
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_RECORDS)) {
              db.createObjectStore(STORE_RECORDS, { keyPath: "_id" });
            }
            if (!db.objectStoreNames.contains(STORE_BATCHES)) {
              db.createObjectStore(STORE_BATCHES, { keyPath: "_batchId" });
            }
            if (!db.objectStoreNames.contains(STORE_ARCHIVES)) {
              db.createObjectStore(STORE_ARCHIVES, { keyPath: "filename" });
            }
          };
        });
      }

      async function clearDBStore(storeName) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([storeName], "readwrite");
          const store = transaction.objectStore(storeName);
          const request = store.clear();
          request.onsuccess = resolve;
          request.onerror = (event) =>
            reject("Clear error: " + event.target.error);
        });
      }

      async function storeRecord(record, id) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_RECORDS], "readwrite");
          const store = transaction.objectStore(STORE_RECORDS);
          record._id = id;
          const request = store.put(record);
          request.onsuccess = resolve;
          request.onerror = (event) =>
            reject("Store error: " + event.target.error);
        });
      }

      async function getRecord(id) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_RECORDS]);
          const store = transaction.objectStore(STORE_RECORDS);
          const request = store.get(id);
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) =>
            reject("Get error: " + event.target.error);
        });
      }

      async function getRecordsCount() {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_RECORDS]);
          const store = transaction.objectStore(STORE_RECORDS);
          const request = store.count();
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) =>
            reject("Count error: " + event.target.error);
        });
      }

      async function storeBatch(batchId, batchData) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_BATCHES], "readwrite");
          const store = transaction.objectStore(STORE_BATCHES);
          const data = { _batchId: batchId, data: batchData };
          const request = store.put(data);
          request.onsuccess = resolve;
          request.onerror = (event) =>
            reject("Store batch error: " + event.target.error);
        });
      }

      async function getBatch(batchId) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_BATCHES]);
          const store = transaction.objectStore(STORE_BATCHES);
          const request = store.get(batchId);
          request.onsuccess = (event) => resolve(event.target.result?.data);
          request.onerror = (event) =>
            reject("Get batch error: " + event.target.error);
        });
      }

      async function getAllBatchKeys() {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_BATCHES]);
          const store = transaction.objectStore(STORE_BATCHES);
          const request = store.getAllKeys();
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) =>
            reject("Get keys error: " + event.target.error);
        });
      }

      async function storeArchive(filename, blob) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_ARCHIVES], "readwrite");
          const store = transaction.objectStore(STORE_ARCHIVES);
          const data = {
            filename,
            blob,
            size: blob.size,
            createdAt: new Date().toISOString(),
          };
          const request = store.put(data);
          request.onsuccess = resolve;
          request.onerror = (event) =>
            reject("Store archive error: " + event.target.error);
        });
      }

      async function getAllArchives() {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_ARCHIVES]);
          const store = transaction.objectStore(STORE_ARCHIVES);
          const request = store.getAll();
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) =>
            reject("Get archives error: " + event.target.error);
        });
      }

      async function deleteArchive(filename) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_ARCHIVES], "readwrite");
          const store = transaction.objectStore(STORE_ARCHIVES);
          const request = store.delete(filename);
          request.onsuccess = resolve;
          request.onerror = (event) =>
            reject("Delete archive error: " + event.target.error);
        });
      }

      async function clearArchives() {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_ARCHIVES], "readwrite");
          const store = transaction.objectStore(STORE_ARCHIVES);
          const request = store.clear();
          request.onsuccess = resolve;
          request.onerror = (event) =>
            reject("Clear archives error: " + event.target.error);
        });
      }

      async function renderDownloadSection() {
        let downloadSection = document.getElementById("downloadSection");
        if (!downloadSection) {
          downloadSection = document.createElement("div");
          downloadSection.id = "downloadSection";
          downloadSection.className = "card";
          downloadSection.innerHTML = `
            <div class="card-header">
              <h2>📥 ไฟล์ที่พร้อมดาวน์โหลด</h2>
            </div>
            <div id="archiveList" style="margin-bottom: 15px;"></div>
            <button class="btn btn-danger" id="clearArchivesBtn">🗑️ ลบไฟล์ทั้งหมด</button>
          `;
          document
            .querySelector(".container")
            .insertBefore(downloadSection, document.querySelector(".footer"));
          document
            .getElementById("clearArchivesBtn")
            .addEventListener("click", async () => {
              await clearArchives();
              log("🧹 ล้างไฟล์ archives ใน IndexedDB เสร็จสิ้น", "info");
              renderArchiveList();
            });
        }
        renderArchiveList();
      }

      async function renderArchiveList() {
        const archives = await getAllArchives();
        const listContainer = document.getElementById("archiveList");
        listContainer.innerHTML = "";
        if (archives.length === 0) {
          listContainer.innerHTML =
            "<p style='text-align: center; color: var(--gray);'>ไม่มีไฟล์ที่บันทึกไว้</p>";
          return;
        }
        archives.forEach((archive) => {
          const item = document.createElement("div");
          item.style =
            "display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid var(--border);";
          item.innerHTML = `
            <span>${archive.filename} (${(archive.size / 1024 / 1024).toFixed(
            2
          )} MB) - สร้างเมื่อ ${archive.createdAt}</span>
            <div>
              <button class="btn btn-primary" style="margin-right: 10px;" data-filename="${
                archive.filename
              }">ดาวน์โหลด</button>
              <button class="btn btn-danger" data-filename="${
                archive.filename
              }">ลบ</button>
            </div>
          `;
          item.querySelector(".btn-primary").addEventListener("click", () => {
            downloadFile(archive.blob, archive.filename);
          });
          item
            .querySelector(".btn-danger")
            .addEventListener("click", async () => {
              await deleteArchive(archive.filename);
              log(`🗑️ ลบไฟล์ ${archive.filename} จาก IndexedDB`, "info");
              renderArchiveList();
            });
          listContainer.appendChild(item);
        });
      }

      function downloadFile(blob, filename) {
        try {
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          setTimeout(() => URL.revokeObjectURL(url), 100);
          log(`✅ ดาวน์โหลดไฟล์ ${filename} สำเร็จ`, "info");
        } catch (e) {
          log(`❌ Error downloading file ${filename}: ${e.message}`, "error");
        }
      }

      const workerCode = () => {
        self.importScripts(
          "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"
        );
        function parseDBFHeader(buffer) {
          try {
            const view = new DataView(buffer);
            const recordCount = view.getUint32(4, true);
            const headerLength = view.getUint16(8, true);
            const recordLength = view.getUint16(10, true);
            const fieldCount = Math.floor((headerLength - 32 - 1) / 32);
            const fields = [];
            let offset = 32;
            self.postMessage({
              action: "log",
              message: `เริ่ม parse DBF header: ${recordCount} records, ${fieldCount} fields`,
              type: "info",
            });
            for (let i = 0; i < fieldCount; i++) {
              const nameBytes = new Uint8Array(
                buffer.slice(offset, offset + 11)
              );
              const name = new TextDecoder("ascii")
                .decode(nameBytes)
                .replace(/\0/g, "")
                .trim();
              const type = String.fromCharCode(
                new Uint8Array(buffer.slice(offset + 11, offset + 12))[0]
              );
              const length = new Uint8Array(
                buffer.slice(offset + 16, offset + 17)
              )[0];
              fields.push({ name, type, length });
              offset += 32;
            }
            return { recordCount, headerLength, recordLength, fields };
          } catch (error) {
            self.postMessage({
              action: "error",
              message: `DBF Header Parsing Error: ${error.message} ที่ offset ${
                offset || 0
              } | Stack: ${error.stack || "ไม่มี"}`,
              type: "error",
            });
            throw error;
          }
        }
        function tryDecode(bytes) {
          const encodings = ["windows-874", "utf-8"];
          for (const encoding of encodings) {
            try {
              return new TextDecoder(encoding).decode(bytes).trim();
            } catch (e) {
              self.postMessage({
                action: "log",
                message: `⚠️ Decoding ล้มเหลวสำหรับ encoding ${encoding}: ${e.message}. ลอง encoding ถัดไป`,
                type: "warning",
              });
              continue;
            }
          }
          self.postMessage({
            action: "log",
            message: `⚠️ ไม่สามารถ decode ได้หลังลองทุก encoding`,
            type: "warning",
          });
          return "[ไม่สามารถถอดรหัสได้]";
        }
        function parseDBFRecords(buffer, header) {
          try {
            const records = [];
            const dataStart = header.headerLength;
            const uint8Array = new Uint8Array(buffer);
            const startTime = Date.now();
            self.postMessage({
              action: "log",
              message: `เริ่ม parse ${header.recordCount} records จาก offset ${dataStart}`,
              type: "info",
            });
            for (let i = 0; i < header.recordCount; i++) {
              const recordOffset = dataStart + i * header.recordLength;
              if (recordOffset + header.recordLength > buffer.byteLength) {
                self.postMessage({
                  action: "error",
                  message: `DBF Records Parsing Error: Offset ${recordOffset} เกินขนาด buffer (${buffer.byteLength}) ที่ record ${i}`,
                  type: "error",
                });
                break;
              }
              if (uint8Array[recordOffset] === 0x2a) continue;
              const record = {};
              let fieldOffset = recordOffset + 1;
              for (const field of header.fields) {
                const fieldBytes = uint8Array.slice(
                  fieldOffset,
                  fieldOffset + field.length
                );
                try {
                  record[field.name] = tryDecode(fieldBytes);
                } catch (e) {
                  self.postMessage({
                    action: "log",
                    message: `⚠️ Decoding ล้มเหลวสำหรับ field ${field.name} ใน record ${i}: ${e.message}. ใช้ fallback "[ไม่สามารถถอดรหัสได้]"`,
                    type: "warning",
                  });
                  record[field.name] = "[ไม่สามารถถอดรหัสได้]";
                }
                fieldOffset += field.length;
              }
              records.push(record);
              if (i % 500 === 0) {
                const elapsed = (Date.now() - startTime) / 1000;
                self.postMessage({
                  action: "log",
                  message: `ประมวลผล ${i} จาก ${
                    header.recordCount
                  } records (ใช้เวลา ${elapsed.toFixed(2)} วินาที)`,
                  type: "info",
                });
                self.postMessage({
                  action: "progress",
                  message: Math.round((i / header.recordCount) * 100),
                });
                if (i % 5000 === 0) {
                  self.postMessage({
                    action: "log",
                    message: `หยุดพักชั่วคราว 100ms เพื่อลดการใช้งาน CPU`,
                    type: "info",
                  });
                  setTimeout(() => {}, 100);
                }
              }
            }
            const totalElapsed = (Date.now() - startTime) / 1000;
            self.postMessage({
              action: "log",
              message: `✅ เสร็จสิ้นการ parse ${
                records.length
              } records ใน ${totalElapsed.toFixed(2)} วินาที`,
              type: "info",
            });
            return records;
          } catch (error) {
            self.postMessage({
              action: "error",
              message: `DBF Records Parsing Error: ${
                error.message
              } ที่ record ${i || 0} | Stack: ${error.stack || "ไม่มี"}`,
              type: "error",
            });
            throw error;
          }
        }
        async function createMIDIZip(midi, lyr, cur, performanceMode) {
          try {
            const zip = new JSZip();
            zip.file("song.mid", midi);
            zip.file("song.lyr", lyr);
            zip.file("song.cur", cur);
            self.postMessage({
              action: "log",
              message: `กำลังสร้าง MIDI ZIP (performanceMode: ${performanceMode})`,
              type: "info",
            });
            const zipData = await zip.generateAsync({
              type: "uint8array",
              compression: performanceMode ? "DEFLATE" : "DEFLATE",
              compressionOptions: performanceMode ? { level: 1 } : { level: 6 },
            });
            self.postMessage({
              action: "log",
              message: `✅ สร้าง MIDI ZIP สำเร็จ (${(
                zipData.length / 1024
              ).toFixed(2)} KB)`,
              type: "info",
            });
            return zipData;
          } catch (error) {
            self.postMessage({
              action: "error",
              message: `MIDI ZIP Creation Error: ${error.message} | Stack: ${
                error.stack || "ไม่มี"
              }`,
              type: "error",
            });
            throw error;
          }
        }
        async function buildSearchIndex(records) {
          try {
            self.postMessage({
              action: "log",
              message: `เริ่มสร้าง search index สำหรับ ${records.length} records`,
              type: "info",
            });
            const wordMap = {};
            const chunks = {};
            let chunkId = 0;
            let currentChunk = {};
            let currentChunkSize = 0;
            const MAX_CHUNK_SIZE = 5 * 1024 * 1024;
            function extractWords(text) {
              return (text.match(/[a-zA-Z\d\u0e00-\u0e7f]+/g) || [])
                .map((w) => w.toLowerCase())
                .filter((w) => w.length > 1);
            }
            for (const record of records) {
              if (
                record._originalIndex === undefined ||
                record._superIndex === undefined
              )
                continue;
              const preview = {
                t: record.TITLE || "",
                a: record.ARTIST || "",
                i: record._originalIndex,
                s: record._superIndex,
              };
              const text = `${record.TITLE} ${record.ARTIST}`;
              const words = extractWords(text);
              for (const word of words) {
                if (!wordMap[word]) wordMap[word] = [];
                wordMap[word].push(preview);
              }
            }
            const sortedWords = Object.keys(wordMap).sort();
            const wordToChunk = {};
            for (const word of sortedWords) {
              const entrySize = JSON.stringify(wordMap[word]).length;
              if (
                currentChunkSize + entrySize > MAX_CHUNK_SIZE &&
                Object.keys(currentChunk).length > 0
              ) {
                chunks[chunkId] = currentChunk;
                chunkId++;
                currentChunk = {};
                currentChunkSize = 0;
              }
              currentChunk[word] = wordMap[word];
              wordToChunk[word] = chunkId;
              currentChunkSize += entrySize;
            }
            if (Object.keys(currentChunk).length > 0) {
              chunks[chunkId] = currentChunk;
            }
            const masterIndex = {
              totalRecords: records.length,
              words: sortedWords,
              wordToChunkMap: wordToChunk,
              buildTime: Date.now(),
              lastBuilt: new Date().toISOString(),
            };
            self.postMessage({
              action: "log",
              message: `✅ สร้าง search index เสร็จสิ้น: ${
                Object.keys(chunks).length
              } chunks`,
              type: "info",
            });
            return { masterIndex, chunks };
          } catch (error) {
            self.postMessage({
              action: "error",
              message: `Search Index Building Error: ${
                error.message
              } | Stack: ${error.stack || "ไม่มี"}`,
              type: "error",
            });
            throw error;
          }
        }
        self.onmessage = async (e) => {
          try {
            const { action, data } = e.data;
            if (action === "parseDBF") {
              const header = parseDBFHeader(data.buffer);
              const records = parseDBFRecords(data.buffer, header);
              self.postMessage({ action: "parseDBFResult", header, records });
            } else if (action === "createMIDIZip") {
              const zipData = await createMIDIZip(
                data.midi,
                data.lyr,
                data.cur,
                data.performanceMode
              );
              self.postMessage({ action: "createMIDIZipResult", zipData });
            } else if (action === "buildSearchIndex") {
              const indexData = await buildSearchIndex(data.records);
              self.postMessage({ action: "buildSearchIndexResult", indexData });
            }
          } catch (error) {
            self.postMessage({
              action: "error",
              message: `Worker Error: ${error.message} | Stack: ${
                error.stack || "ไม่มี"
              }`,
              type: "error",
            });
          }
        };
      };
      const blob = new Blob([`(${workerCode.toString()})()`], {
        type: "application/javascript",
      });
      const workerURL = URL.createObjectURL(blob);
      worker = new Worker(workerURL);
      worker.onmessage = (e) => {
        const { action, message, header, records, zipData, indexData, type } =
          e.data;
        if (action === "parseDBFResult") {
          workerParseDBFResult(header, records);
        } else if (action === "createMIDIZipResult") {
          workerCreateMIDIZipResult(zipData);
        } else if (action === "buildSearchIndexResult") {
          workerBuildSearchIndexResult(indexData);
        } else if (action === "log") {
          log(message, type);
        } else if (action === "progress") {
          updateStatus(`กำลัง parse ไฟล์ DBF: ${message}%`);
        } else if (action === "error") {
          log(`❌ Worker Error: ${message}`, "error");
          updateStatus("❌ เกิดข้อผิดพลาดใน Worker");
          isProcessing = false;
          elements.startBtn.disabled = false;
          elements.stopBtn.disabled = true;
        }
      };

      async function getFileByPath(pathParts) {
        const fullPath = pathParts.join("/");
        try {
          if (rootDirHandle) {
            let currentHandle = rootDirHandle;
            for (let i = 0; i < pathParts.length - 1; i++) {
              currentHandle = await currentHandle.getDirectoryHandle(
                pathParts[i],
                {
                  create: false,
                }
              );
            }
            const fileName = pathParts[pathParts.length - 1];
            const fileHandle = await currentHandle.getFileHandle(fileName);
            const file = await fileHandle.getFile();
            return { arrayBuffer: () => file.arrayBuffer() };
          }
          return null;
        } catch (e) {
          log(`⚠️ ไม่พบไฟล์ ${fullPath}: ${e.message}`, "warning");
          return null;
        }
      }

      async function getSongFiles(track) {
        if (!track.CODE || !track.TYPE || !track.SUB_TYPE) {
          log(`⚠️ Track ข้อมูลไม่ครบ: ${JSON.stringify(track)}`, "warning");
          return null;
        }
        const code = track.CODE;
        const folder = code[0];
        const primaryPath = ["Songs", track.TYPE, track.SUB_TYPE];
        try {
          if (track.SUB_TYPE === "EMK") {
            let emkFile = await getFileByPath([
              ...primaryPath,
              folder,
              `${code}.emk`,
            ]);
            if (!emkFile) {
              emkFile = await getFileByPath([...primaryPath, `${code}.emk`]);
            }
            if (emkFile) {
              log(`✅ พบไฟล์ EMK: ${code}.emk`, "info");
              return { emk: await emkFile.arrayBuffer() };
            }
          } else if (track.SUB_TYPE === "NCN") {
            const [midiFile, lyrFile, curFile] = await Promise.all([
              getFileByPath([...primaryPath, "Song", folder, `${code}.mid`]) ||
                getFileByPath([...primaryPath, "Song", `${code}.mid`]),
              getFileByPath([
                ...primaryPath,
                "Lyrics",
                folder,
                `${code}.lyr`,
              ]) || getFileByPath([...primaryPath, "Lyrics", `${code}.lyr`]),
              getFileByPath([
                ...primaryPath,
                "Cursor",
                folder,
                `${code}.cur`,
              ]) || getFileByPath([...primaryPath, "Cursor", `${code}.cur`]),
            ]);
            if (midiFile && lyrFile && curFile) {
              const [midi, lyr, cur] = await Promise.all([
                midiFile.arrayBuffer(),
                lyrFile.arrayBuffer(),
                curFile.arrayBuffer(),
              ]);
              log(`✅ พบไฟล์ NCN: ${code}.mid, .lyr, .cur`, "info");
              return { midi, lyr, cur };
            }
          }
          log(`⚠️ ไม่พบไฟล์สำหรับ track ${code}`, "warning");
          return null;
        } catch (e) {
          log(
            `❌ Error fetching song files for ${code}: ${e.message} | Stack: ${
              e.stack || "ไม่มี"
            }`,
            "error"
          );
          return null;
        }
      }

      let workerParseDBFResultResolve = null;
      let workerCreateMIDIZipResultResolve = null;
      let workerBuildSearchIndexResultResolve = null;

      function workerParseDBFResult(header, records) {
        if (workerParseDBFResultResolve) {
          workerParseDBFResultResolve({ header, records });
          workerParseDBFResultResolve = null;
        }
      }

      function workerCreateMIDIZipResult(zipData) {
        if (workerCreateMIDIZipResultResolve) {
          workerCreateMIDIZipResultResolve(zipData);
          workerCreateMIDIZipResultResolve = null;
        }
      }

      function workerBuildSearchIndexResult(indexData) {
        if (workerBuildSearchIndexResultResolve) {
          workerBuildSearchIndexResultResolve(indexData);
          workerBuildSearchIndexResultResolve = null;
        }
      }

      async function parseDBF(buffer) {
        return new Promise((resolve, reject) => {
          workerParseDBFResultResolve = resolve;
          worker.postMessage({ action: "parseDBF", data: { buffer } });
          setTimeout(
            () =>
              reject(
                new Error(
                  "DBF parsing timeout หลังจาก 10 นาที: ไฟล์อาจใหญ่เกินไปหรือเครื่องช้า"
                )
              ),
            600000
          );
        });
      }

      async function createMIDIZip(midi, lyr, cur, performanceMode) {
        return new Promise((resolve, reject) => {
          workerCreateMIDIZipResultResolve = resolve;
          worker.postMessage({
            action: "createMIDIZip",
            data: { midi, lyr, cur, performanceMode },
          });
          setTimeout(
            () => reject(new Error("MIDI ZIP creation timeout")),
            10000
          );
        });
      }

      async function buildSearchIndex(records) {
        return new Promise((resolve, reject) => {
          workerBuildSearchIndexResultResolve = resolve;
          worker.postMessage({ action: "buildSearchIndex", data: { records } });
          setTimeout(
            () => reject(new Error("Search index building timeout")),
            60000
          );
        });
      }

      const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

      async function processKaraoke() {
        shouldStop = false;
        isProcessing = true;
        try {
          await initDB();
          await clearDBStore(STORE_RECORDS);
          await clearDBStore(STORE_BATCHES);
          if (!rootDirHandle) {
            throw new Error("กรุณาเลือกโฟลเดอร์ก่อน");
          }
          updateStatus("กำลังอ่านไฟล์ SONG.DBF...");
          log("📖 อ่านไฟล์ Data/SONG.DBF", "info");
          const dbfFile = await getFileByPath(["Data", "SONG.DBF"]);
          if (!dbfFile) {
            throw new Error("ไม่พบไฟล์ Data/SONG.DBF ในโฟลเดอร์ที่เลือก");
          }
          const dbfBuffer = await dbfFile.arrayBuffer();
          updateProgress(5);
          log(
            `✅ อ่านไฟล์ SONG.DBF สำเร็จ (${(
              dbfBuffer.byteLength /
              1024 /
              1024
            ).toFixed(2)} MB)`,
            "info"
          );
          updateStatus("กำลังวิเคราะห์โครงสร้าง DBF...");
          log("🔍 วิเคราะห์ DBF header...", "info");
          let { header, records } = await parseDBF(dbfBuffer);
          log(
            `✅ พบ ${header.recordCount} records, ${header.fields.length} fields`,
            "info"
          );
          updateProgress(10);
          updateStatus("กำลังบันทึกข้อมูลลงฐานข้อมูล...");
          log(`💾 บันทึก ${records.length} records ลง IndexedDB...`, "info");
          for (let i = 0; i < records.length; i++) {
            await storeRecord(records[i], i);
            if (i % 1000 === 0) {
              updateStatus(`บันทึก record ${i}/${records.length}`);
            }
          }
          records = null;
          updateProgress(15);
          if (shouldStop) throw new Error("หยุดโดยผู้ใช้");
          const config = {
            batchSize: parseInt(elements.batchSize.value),
            zipSizeLimit: parseInt(elements.zipSizeLimit.value) * 1024 * 1024,
            cpuThrottle: parseInt(elements.cpuThrottle.value),
            createZips: elements.createZips.checked,
            createIndexZip: elements.createIndexZip.checked,
            performanceMode: elements.performanceMode.checked,
          };
          log(
            `⚙️ การตั้งค่า: Batch=${config.batchSize}, ZIP Limit=${(
              config.zipSizeLimit /
              1024 /
              1024
            ).toFixed(0)}MB, Throttle=${config.cpuThrottle}ms, Performance=${
              config.performanceMode
            }`,
            "info"
          );
          updateStatus("กำลังประมวลผลไฟล์เพลง...");
          const totalRecords = await getRecordsCount();
          let successCount = 0;
          let currentBatch = [];
          let currentBatchZip = config.createZips ? new JSZip() : null;
          let currentBatchSize = 0;
          let batchIndex = 0;
          const parallelBatchSize = config.performanceMode ? 50 : 20;
          const compressionLevel = config.performanceMode ? 1 : 3;
          for (let i = 0; i < totalRecords; i += parallelBatchSize) {
            if (shouldStop) throw new Error("หยุดโดยผู้ใช้");
            const end = Math.min(i + parallelBatchSize, totalRecords);
            const batchPromises = [];
            for (let j = i; j < end; j++) {
              batchPromises.push(
                (async () => {
                  const track = await getRecord(j);
                  if (!track) {
                    log(`⚠️ ไม่พบ record ที่ index ${j}`, "warning");
                    return null;
                  }
                  try {
                    const files = await getSongFiles(track);
                    if (!files) return null;
                    let content = null;
                    let filename = "";
                    if (
                      track.SUB_TYPE === "NCN" &&
                      files.midi &&
                      files.lyr &&
                      files.cur
                    ) {
                      updateStatus(`สร้าง ZIP สำหรับ track ${j} (NCN)`);
                      const zip = new JSZip();
                      zip.file("song.mid", files.midi);
                      zip.file("song.lyr", files.lyr);
                      zip.file("song.cur", files.cur);
                      content = await zip.generateAsync({
                        type: "uint8array",
                        compression: "DEFLATE",
                        compressionOptions: { level: compressionLevel },
                      });
                      filename = `${j}.zip`;
                    } else if (track.SUB_TYPE === "EMK" && files.emk) {
                      content = new Uint8Array(files.emk);
                      filename = `${j}.emk`;
                    }
                    track._originalIndex = j;
                    track._superIndex = batchIndex;
                    await storeRecord(track, j);
                    successCount++;
                    return { trackId: j, content, filename };
                  } catch (e) {
                    log(
                      `❌ Error processing track ${j}: ${e.message} | Stack: ${
                        e.stack || "ไม่มี"
                      }`,
                      "error"
                    );
                    return null;
                  }
                })()
              );
            }
            const results = await Promise.all(batchPromises);
            results.forEach((result) => {
              if (result && result.content) {
                currentBatch.push(result);
                if (config.createZips && currentBatchZip) {
                  currentBatchZip.file(result.filename, result.content);
                  currentBatchSize += result.content.length;
                }
              }
            });
            if (
              currentBatch.length >= config.batchSize ||
              (config.createZips && currentBatchSize >= config.zipSizeLimit)
            ) {
              if (config.createZips && currentBatchZip) {
                updateStatus(`บันทึก batch ${batchIndex}...`);
                log(
                  `💾 บันทึก batch ${batchIndex}: ${
                    currentBatch.length
                  } เพลง (${(currentBatchSize / 1024 / 1024).toFixed(2)}MB)`,
                  "info"
                );
                const batchData = await currentBatchZip.generateAsync({
                  type: "uint8array",
                  compression: config.performanceMode ? "DEFLATE" : "DEFLATE",
                  compressionOptions: config.performanceMode
                    ? { level: 1 }
                    : { level: 6 },
                });
                await storeBatch(batchIndex, batchData);
                currentBatchZip = null;
              }
              batchIndex++;
              currentBatch = [];
              currentBatchZip = config.createZips ? new JSZip() : null;
              currentBatchSize = 0;
            }
            const progress = 15 + Math.floor((end / totalRecords) * 70);
            updateProgress(progress);
            updateStatus(`ประมวลผลเพลง: ${successCount}/${totalRecords}`);
            log(
              `⏳ ประมวลผล: ${successCount}/${totalRecords} (${end} records)`,
              "info"
            );
            if (
              (i % 100 === 0 || end >= totalRecords) &&
              config.cpuThrottle > 0
            ) {
              await sleep(
                config.performanceMode
                  ? Math.min(config.cpuThrottle, 1)
                  : config.cpuThrottle
              );
            }
          }
          if (currentBatch.length > 0 && config.createZips && currentBatchZip) {
            updateStatus(`บันทึก batch สุดท้าย ${batchIndex}...`);
            log(
              `💾 บันทึก batch สุดท้าย ${batchIndex}: ${currentBatch.length} เพลง`,
              "info"
            );
            const batchData = await currentBatchZip.generateAsync({
              type: "uint8array",
              compression: config.performanceMode ? "DEFLATE" : "DEFLATE",
              compressionOptions: config.performanceMode
                ? { level: 1 }
                : { level: 6 },
            });
            await storeBatch(batchIndex, batchData);
            currentBatchZip = null;
          }
          updateProgress(85);
          log(
            `✅ ประมวลผลเพลงเสร็จ: ${successCount} จาก ${totalRecords} records`,
            "info"
          );
          if (config.createZips) {
            updateStatus("กำลังบันทึกไฟล์ karaoke_*.zip ลงฐานข้อมูล...");
            log("📦 บันทึก karaoke archives ลง IndexedDB...", "info");
            let archiveIndex = 0;
            let currentArchive = new JSZip();
            let currentArchiveSize = 0;
            const batchKeys = await getAllBatchKeys();
            for (const batchId of batchKeys.sort((a, b) => a - b)) {
              const batchData = await getBatch(batchId);
              if (
                currentArchiveSize + batchData.length > config.zipSizeLimit &&
                currentArchiveSize > 0
              ) {
                updateStatus(`บันทึก karaoke_${archiveIndex}.zip...`);
                const archiveData = await currentArchive.generateAsync({
                  type: "blob",
                  compression: config.performanceMode ? "DEFLATE" : "DEFLATE",
                  compressionOptions: config.performanceMode
                    ? { level: 1 }
                    : { level: 6 },
                });
                await storeArchive(`karaoke_${archiveIndex}.zip`, archiveData);
                log(
                  `✅ บันทึก karaoke_${archiveIndex}.zip ลง IndexedDB (${(
                    archiveData.size /
                    1024 /
                    1024
                  ).toFixed(2)}MB)`,
                  "info"
                );
                archiveIndex++;
                currentArchive = new JSZip();
                currentArchiveSize = 0;
              }
              currentArchive.file(`${batchId}.zip`, batchData);
              currentArchiveSize += batchData.length;
            }
            if (currentArchiveSize > 0) {
              updateStatus(`บันทึก karaoke_${archiveIndex}.zip...`);
              const archiveData = await currentArchive.generateAsync({
                type: "blob",
                compression: config.performanceMode ? "DEFLATE" : "DEFLATE",
                compressionOptions: { level: config.performanceMode ? 1 : 6 },
              });
              await storeArchive(`karaoke_${archiveIndex}.zip`, archiveData);
              log(
                `✅ บันทึก karaoke_${archiveIndex}.zip ลง IndexedDB (${(
                  archiveData.size /
                  1024 /
                  1024
                ).toFixed(2)}MB)`,
                "info"
              );
            }
          }
          updateProgress(95);
          if (config.createIndexZip) {
            updateStatus("กำลังบันทึก index.zip ลงฐานข้อมูล...");
            log("🔍 บันทึก search index ลง IndexedDB...", "info");
            const recordsForIndex = [];
            const total = await getRecordsCount();
            const indexBatchSize = 500;
            for (let i = 0; i < total; i += indexBatchSize) {
              const end = Math.min(i + indexBatchSize, total);
              for (let j = i; j < end; j++) {
                const record = await getRecord(j);
                if (record) recordsForIndex.push(record);
              }
            }
            const { masterIndex, chunks } = await buildSearchIndex(
              recordsForIndex
            );
            const indexZip = new JSZip();
            indexZip.file("master.json", JSON.stringify(masterIndex));
            for (const chunkId in chunks) {
              indexZip.file(
                `chunk_${chunkId}.json`,
                JSON.stringify(chunks[chunkId])
              );
            }
            const indexZipData = await indexZip.generateAsync({ type: "blob" });
            await storeArchive("index.zip", indexZipData);
            log(
              `✅ บันทึก index.zip ลง IndexedDB (${(
                indexZipData.size / 1024
              ).toFixed(2)}KB)`,
              "info"
            );
          }
          updateProgress(100);
          updateStatus("🎉 เสร็จสิ้นการประมวลผล! ไฟล์พร้อมดาวน์โหลดด้านล่าง");
          log("🎉 การประมวลผลเสร็จสมบูรณ์! ไฟล์ถูกบันทึกในฐานข้อมูล", "info");
          await renderDownloadSection();
        } catch (error) {
          if (error.message === "หยุดโดยผู้ใช้") {
            log("⏹️ การทำงานหยุดลงตามคำสั่งผู้ใช้", "warning");
            updateStatus("⏹️ หยุดการทำงานแล้ว");
          } else {
            log(
              `❌ เกิดข้อผิดพลาดร้ายแรง: ${error.message} | Stack: ${
                error.stack || "ไม่มี stack trace"
              }`,
              "error"
            );
            if (error.message.includes("DBF parsing timeout")) {
              log(
                "⚠️ สาเหตุที่เป็นไปได้: ไฟล์ SONG.DBF อาจมีขนาดใหญ่เกินไป (จำนวน records เยอะหรือไฟล์ >100MB). แนะนำ: ลองใช้เครื่องที่มีประสิทธิภาพสูงขึ้น, เพิ่ม CPU Throttle, หรือแบ่งไฟล์ DBF เป็นส่วนย่อยๆ.",
                "warning"
              );
            } else if (error.message.includes("ไม่พบไฟล์")) {
              log(
                "⚠️ สาเหตุที่เป็นไปได้: โฟลเดอร์ที่เลือกไม่มีไฟล์ SONG.DBF หรือโครงสร้างโฟลเดอร์ไม่ถูกต้อง. กรุณาตรวจสอบว่าเลือกโฟลเดอร์คาราโอเกะที่ถูกต้อง.",
                "warning"
              );
            } else {
              log(
                "⚠️ สาเหตุที่เป็นไปได้: ไฟล์เสียหาย, เบราว์เซอร์ไม่รองรับ, หรือหน่วยความจำไม่เพียงพอ. ลองใช้ Chrome ล่าสุดและตรวจสอบว่าไฟล์ครบถ้วน.",
                "warning"
              );
            }
            updateStatus(`❌ เกิดข้อผิดพลาด: ${error.message}`);
          }
        } finally {
          isProcessing = false;
          elements.startBtn.disabled = false;
          elements.stopBtn.disabled = true;
          await clearDBStore(STORE_RECORDS);
          await clearDBStore(STORE_BATCHES);
          log("🧹 ล้างฐานข้อมูล IndexedDB เสร็จสิ้น", "info");
        }
      }

      elements.selectFolderBtn.addEventListener("click", async () => {
        if ("showDirectoryPicker" in window) {
          try {
            const handle = await window.showDirectoryPicker();
            rootDirHandle = handle;
            elements.inputInfo.textContent = `📁 โฟลเดอร์: ${handle.name}`;
            elements.inputInfo.classList.add("active");
            log(`📁 เลือกโฟลเดอร์: ${handle.name}`, "info");
          } catch (err) {
            log(`⚠️ ผู้ใช้ยกเลิกการเลือกโฟลเดอร์: ${err.message}`, "warning");
            updateStatus("⚠️ ไม่ได้เลือกโฟลเดอร์");
          }
        } else {
          log(
            "❌ เบราว์เซอร์ไม่รองรับ File System Access API (ต้องการ Chrome 86+ หรือ Edge 86+)",
            "error"
          );
          updateStatus("❌ เบราว์เซอร์ไม่รองรับ API");
          alert("เบราว์เซอร์ของคุณไม่รองรับ File System Access API");
        }
      });

      elements.startBtn.addEventListener("click", () => {
        if (!rootDirHandle) {
          log("⚠️ กรุณาเลือกโฟลเดอร์ก่อนเริ่มประมวลผล", "warning");
          updateStatus("⚠️ กรุณาเลือกโฟลเดอร์");
          return;
        }
        if (isProcessing) {
          log("⚠️ อยู่ระหว่างการประมวลผล", "warning");
          return;
        }
        elements.logBox.innerHTML = "";
        elements.startBtn.disabled = true;
        elements.stopBtn.disabled = false;
        updateProgress(0);
        updateStatus("เริ่มประมวลผล...");
        log("🚀 เริ่มการประมวลผลคาราโอเกะ", "info");
        processKaraoke();
      });

      elements.stopBtn.addEventListener("click", () => {
        if (isProcessing) {
          shouldStop = true;
          log("⏹️ ส่งคำสั่งหยุดการประมวลผล", "warning");
          updateStatus("กำลังหยุด...");
          elements.stopBtn.disabled = true;
        }
      });

      // โหลด archives ที่ค้างอยู่ตอนเปิดหน้า
      window.addEventListener("load", async () => {
        await initDB();
        const archives = await getAllArchives();
        if (archives.length > 0) {
          renderDownloadSection();
          log(
            `🔄 พบ ${archives.length} ไฟล์ที่บันทึกค้างไว้จากครั้งก่อน`,
            "info"
          );
        }
      });
    </script>
  </body>
</html>
